/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_alchemy-sdk_dist_esm_alchemy-websocket-provider-3d48e6c0_js"],{

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js":
/*!************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyProvider\": function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-32cab09d.js */ \"./node_modules/alchemy-sdk/dist/esm/index-32cab09d.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/providers */ \"./node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/web */ \"./node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.C) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.g)(network, apiKey)\r\n            : (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-932953e4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS1wcm92aWRlci05MzI5NTNlNC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTBRO0FBQ3JOO0FBQ007QUFDWjtBQUMxQjtBQUNhO0FBQ25CO0FBQzJCO0FBQ1g7QUFDRzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZUFBZSxVQUFVLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsdUNBQXVDLDhCQUE4QiwwQ0FBMEMsR0FBRztBQUN4TTtBQUNBLG1CQUFtQiw2REFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQXVCO0FBQzFDO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpREFBYztBQUNwRSxtQkFBbUIsaURBQWM7QUFDakM7QUFDQTtBQUNBLGVBQWUsbUVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBZTtBQUNsQztBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBLDZDQUE2QyxpREFBTztBQUNwRDtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hELG1CQUFtQixjQUFjLGlEQUFPLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMscURBQWlCO0FBQy9CLGNBQWMscURBQWU7QUFDN0I7QUFDQSxxQkFBcUIsaURBQVU7QUFDL0I7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQTtBQUNBLGtEQUFrRCxpREFBTztBQUN6RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNULGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBUSxxREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQXVCO0FBQ3REO0FBQ0E7QUFDQSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFEQUFRO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2REFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS1wcm92aWRlci05MzI5NTNlNC5qcz83MWQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX19hd2FpdGVyLCBEIGFzIERFRkFVTFRfQUxDSEVNWV9BUElfS0VZLCBDIGFzIEN1c3RvbU5ldHdvcmtzLCBhIGFzIERFRkFVTFRfTkVUV09SSywgTiBhcyBOZXR3b3JrLCBJIGFzIElTX0JST1dTRVIsIFYgYXMgVkVSU0lPTiwgbCBhcyBsb2dXYXJuLCBkIGFzIGRlZXBDb3B5LCBFIGFzIEV0aGVyc05ldHdvcmssIGcgYXMgZ2V0QWxjaGVteUh0dHBVcmwsIGIgYXMgZ2V0QWxjaGVteVdzVXJsIH0gZnJvbSAnLi9pbmRleC0zMmNhYjA5ZC5qcyc7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvbmV0d29ya3MnO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcbmltcG9ydCB7IGZldGNoSnNvbiB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L3dlYic7XG5pbXBvcnQgJy4vYXBpL3V0aWxzJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyJztcbmltcG9ydCAnYXhpb3MnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcic7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L3dhbGxldCc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cyc7XG5cbi8qKiBNYXhpbXVtIHNpemUgb2YgYSBiYXRjaCBvbiB0aGUgcnBjIHByb3ZpZGVyLiAqL1xyXG5jb25zdCBERUZBVUxUX01BWF9SRVFVRVNUX0JBVENIX1NJWkUgPSAxMDA7XHJcbi8qKiBUaW1lb3V0IGludGVydmFsIGJlZm9yZSB0aGUgcGVuZGluZyBiYXRjaCBpcyBzZW50LiAqL1xyXG5jb25zdCBERUZBVUxUX1JFUVVFU1RfQkFUQ0hfREVMQVlfTVMgPSAxMDtcclxuLyoqXHJcbiAqIEludGVybmFsIGNsYXNzIHRvIGVucXVldWUgcmVxdWVzdHMgYW5kIGF1dG9tYXRpY2FsbHkgc2VuZC9wcm9jZXNzIGJhdGNoZXMuXHJcbiAqXHJcbiAqIFRoZSB1bmRlcmx5aW5nIGJhdGNoaW5nIG1lY2hhbmlzbSBpcyBsb29zZWx5IGJhc2VkIG9uIGV0aGVycy5qcydzXHJcbiAqIGBKc29uUnBjQmF0Y2hQcm92aWRlcmAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUmVxdWVzdEJhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2VuZEJhdGNoRm4sIG1heEJhdGNoU2l6ZSA9IERFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSkge1xyXG4gICAgICAgIHRoaXMuc2VuZEJhdGNoRm4gPSBzZW5kQmF0Y2hGbjtcclxuICAgICAgICB0aGlzLm1heEJhdGNoU2l6ZSA9IG1heEJhdGNoU2l6ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcnJheSBvZiBlbnF1ZXVlZCByZXF1ZXN0cyBhbG9uZyB3aXRoIHRoZSBjb25zdHJ1Y3RlZCBwcm9taXNlIGhhbmRsZXJzIGZvclxyXG4gICAgICAgICAqIGVhY2ggcmVxdWVzdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaCA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyB0aGUgcHJvdmlkZWQgcmVxdWVzdC4gVGhlIGJhdGNoIGlzIGltbWVkaWF0ZWx5IHNlbnQgaWYgdGhlIG1heGltdW1cclxuICAgICAqIGJhdGNoIHNpemUgaXMgcmVhY2hlZC4gT3RoZXJ3aXNlLCB0aGUgcmVxdWVzdCBpcyBlbnF1ZXVlZCBvbnRvIGEgYmF0Y2ggdGhhdFxyXG4gICAgICogaXMgc2VudCBhZnRlciAxMG1zLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIHJlamVjdDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0ID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2gucHVzaChpbmZsaWdodFJlcXVlc3QpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQmF0Y2gubGVuZ3RoID09PSB0aGlzLm1heEJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBiYXRjaCBpbW1lZGlhdGVseSBpZiB3ZSBhcmUgYXQgdGhlIG1heGltdW0gYmF0Y2ggc2l6ZS5cclxuICAgICAgICAgICAgICAgIHZvaWQgdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGJhdGNoIGZvciBuZXh0IGV2ZW50IGxvb3AgKyBzaG9ydCBkdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kQmF0Y2hSZXF1ZXN0KCksIERFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmRzIHRoZSBjdXJyZW50bHkgcXVldWVkIGJhdGNoZXMgYW5kIHJlc2V0cyB0aGUgYmF0Y2ggYW5kIHRpbWVyLiBQcm9jZXNzZXNcclxuICAgICAqIHRoZSBiYXRjaGVkIHJlc3BvbnNlIHJlc3VsdHMgYmFjayB0byB0aGUgb3JpZ2luYWwgcHJvbWlzZXMuXHJcbiAgICAgKi9cclxuICAgIHNlbmRCYXRjaFJlcXVlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXHJcbiAgICAgICAgICAgIC8vIGdvIGludG8gdGhlIG5leHQgYmF0Y2hcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLnBlbmRpbmdCYXRjaDtcclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2ggPSBbXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0JhdGNoVGltZXIpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlbmRpbmdCYXRjaFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0JhdGNoVGltZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBiYXRjaC5tYXAoaW5mbGlnaHQgPT4gaW5mbGlnaHQucmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRCYXRjaEZuKHJlcXVlc3QpLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcclxuICAgICAgICAgICAgICAgIC8vIG9uIHdoZXRoZXIgaXQgd2FzIGEgc3VjY2VzcyBvciBlcnJvclxyXG4gICAgICAgICAgICAgICAgYmF0Y2guZm9yRWFjaCgoaW5mbGlnaHRSZXF1ZXN0LCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUocGF5bG9hZC5yZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKGluZmxpZ2h0UmVxdWVzdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMuanMncyAnQWxjaGVteVByb3ZpZGVyJy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2ZcclxuICoge0BsaW5rIEFsY2hlbXl9IGFuZCBjYWxsIHtAbGluayBBbGNoZW15LmNvbmZpZy5nZXRQcm92aWRlcigpfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteVByb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQVBJIEtleSB0byBhIHN0cmluZy5cclxuICAgICAgICBjb25zdCBhcGlLZXkgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIG91ciBvd24gY29ubmVjdGlvbiBpbmZvIHdpdGggdGhlIGNvcnJlY3QgZW5kcG9pbnQgVVJMcy5cclxuICAgICAgICBjb25zdCBhbGNoZW15TmV0d29yayA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15TmV0d29yayhjb25maWcubmV0d29yayk7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15Q29ubmVjdGlvbkluZm8oYWxjaGVteU5ldHdvcmssIGFwaUtleSwgJ2h0dHAnKTtcclxuICAgICAgICAvLyBJZiBhIGhhcmRjb2RlZCB1cmwgd2FzIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZVxyXG4gICAgICAgIC8vIHByb3ZpZGVkIGFwaUtleSBvciBuZXR3b3JrLlxyXG4gICAgICAgIGlmIChjb25maWcudXJsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29ubmVjdGlvbi51cmwgPSBjb25maWcudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgPSBjb25maWcubWF4UmV0cmllcztcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFsY2hlbXkgbmFtZWQgbmV0d29yayBpbnB1dCB0byB0aGUgbmV0d29yayBuYW1lcyB1c2VkIGJ5XHJcbiAgICAgICAgLy8gZXRoZXJzLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IHN1cGVyIGNvbnN0cnVjdG9yIGluIEpzb25ScGNQcm92aWRlciB0b1xyXG4gICAgICAgIC8vIGNvcnJlY3RseSBzZXQgdGhlIG5ldHdvcmsuXHJcbiAgICAgICAgY29uc3QgZXRoZXJzTmV0d29yayA9IEV0aGVyc05ldHdvcmtbYWxjaGVteU5ldHdvcmtdO1xyXG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIGV0aGVyc05ldHdvcmspO1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gY29uZmlnLmFwaUtleTtcclxuICAgICAgICB0aGlzLm1heFJldHJpZXMgPSBjb25maWcubWF4UmV0cmllcztcclxuICAgICAgICB0aGlzLmJhdGNoUmVxdWVzdHMgPSBjb25maWcuYmF0Y2hSZXF1ZXN0cztcclxuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IGluZGl2aWR1YWwgaGVhZGVycyB3aGVuIGNhbGxpbmcgYmF0Y2hcclxuICAgICAgICBjb25zdCBiYXRjaGVyQ29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbi5oZWFkZXJzKSwgeyAnQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCc6ICdiYXRjaFNlbmQnIH0pIH0pO1xyXG4gICAgICAgIGNvbnN0IHNlbmRCYXRjaEZuID0gKHJlcXVlc3RzKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBmZXRjaEpzb24oYmF0Y2hlckNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RzKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoc2VuZEJhdGNoRm4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBVcmxKc29uUnBjUHJvdmlkZXIuZ2V0QXBpS2V5YCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnlcclxuICAgICAqIGV0aGVycy5qcy4gUmV0dXJucyB0aGUgQVBJIGtleSBmb3IgYW4gQWxjaGVteSBwcm92aWRlci5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xyXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFwaUtleSAnJHthcGlLZXl9JyBwcm92aWRlZC4gYXBpS2V5IG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcGlLZXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBDdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBgTmV0d29ya2lzaGAgaW5wdXQgdG8gdGhlIG5ldHdvcmsgZW51bSB1c2VkIGJ5IEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9ORVRXT1JLO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIGEgc3RyaW5nLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHdWFyYW50ZWVkIHRoYXQgYHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nYC5cclxuICAgICAgICBjb25zdCBpc1ZhbGlkTmV0d29yayA9IE9iamVjdC52YWx1ZXMoTmV0d29yaykuaW5jbHVkZXMobmV0d29yayk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkTmV0d29yaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbmV0d29yayAnJHtuZXR3b3JrfScgcHJvdmlkZWQuIE5ldHdvcmsgbXVzdCBiZSBvbmUgb2Y6IGAgK1xyXG4gICAgICAgICAgICAgICAgYCR7T2JqZWN0LnZhbHVlcyhOZXR3b3JrKS5qb2luKCcsICcpfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgQ29ubmVjdGlvbkluZm99IG9iamVjdCBjb21wYXRpYmxlIHdpdGggZXRoZXJzIHRoYXQgY29udGFpbnNcclxuICAgICAqIHRoZSBjb3JyZWN0IFVSTHMgZm9yIEFsY2hlbXkuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBbGNoZW15Q29ubmVjdGlvbkluZm8obmV0d29yaywgYXBpS2V5LCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3QgdXJsID0gdHlwZSA9PT0gJ2h0dHAnXHJcbiAgICAgICAgICAgID8gZ2V0QWxjaGVteUh0dHBVcmwobmV0d29yaywgYXBpS2V5KVxyXG4gICAgICAgICAgICA6IGdldEFsY2hlbXlXc1VybChuZXR3b3JrLCBhcGlLZXkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IElTX0JST1dTRVJcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT05cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICdBbGNoZW15LUV0aGVycy1TZGstVmVyc2lvbic6IFZFUlNJT04sXHJcbiAgICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1FbmNvZGluZyc6ICdnemlwJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxyXG4gICAgICAgICAgICB1cmxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBldGhlcnMuanMncyBgU3RhdGljSnNvblJwY1Byb3ZpZGVyYCBjbGFzcy4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIGNhbGxlZCB3aGVuIGNhbGxpbmcgbWV0aG9kcyBvbiB0aGUgcGFyZW50IGNsYXNzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xyXG4gICAgICAgICAgICBkZXRlY3ROZXR3b3JrOiB7IGdldDogKCkgPT4gc3VwZXIuZGV0ZWN0TmV0d29yayB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBuZXR3b3JrIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQZW5kaW5nKCkge1xyXG4gICAgICAgIGxvZ1dhcm4oJ1dBUk5JTkc6IEFsY2hlbXkgUHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBwZW5kaW5nIGZpbHRlcnMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGJhc2Uge0BsaW5rIEpzb25ScGNQcm92aWRlci5zZW5kfSBtZXRob2QgdG8gaW1wbGVtZW50IGN1c3RvbVxyXG4gICAgICogbG9naWMgZm9yIHNlbmRpbmcgcmVxdWVzdHMgdG8gQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWV0aG9kIFRoZSBtZXRob2QgbmFtZSB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1ldGVycyB0byB1c2UgZm9yIHRoZSByZXF1ZXN0LlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IEFkZCBoZWFkZXJzIGZvciBgcGVyZm9ybSgpYCBvdmVycmlkZS5cclxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VuZChtZXRob2QsIHBhcmFtcywgJ3NlbmQnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgSnNvblJwY1Byb3ZpZGVyLnNlbmQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IGN1c3RvbSBoZWFkZXJzXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zZW5kKG1ldGhvZCwgcGFyYW1zLCBtZXRob2ROYW1lLCBmb3JjZUJhdGNoID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRJZCsrLFxyXG4gICAgICAgICAgICBqc29ucnBjOiAnMi4wJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pO1xyXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVyc1snQWxjaGVteS1FdGhlcnMtU2RrLU1ldGhvZCddID0gbWV0aG9kTmFtZTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaFJlcXVlc3RzIHx8IGZvcmNlQmF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hlci5lbnF1ZXVlUmVxdWVzdChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICBhY3Rpb246ICdyZXF1ZXN0JyxcclxuICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXHJcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgY2FuIGV4cGFuZCB0aGlzIGluIHRoZSBmdXR1cmUgdG8gYW55IGNhbGwsIGJ1dCBmb3Igbm93IHRoZXNlXHJcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gWydldGhfY2hhaW5JZCcsICdldGhfYmxvY2tOdW1iZXInXS5pbmRleE9mKG1ldGhvZCkgPj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlYnVnJywge1xyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAncmVzcG9uc2UnLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxyXG4gICAgICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUaGlzIGlzIGRvbmUgYnkgZXRoZXJzLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBETyBOT1QgTU9ESUZZLlxyXG4gKlxyXG4gKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMnc1xyXG4gKiBgQGV0aGVyc3Byb2plY3Qvd2ViL3NyYy50cy9pbmRleC50c2AuIFVzZWQgdG8gc3VwcG9ydFxyXG4gKiB7QGxpbmsgQWxjaGVteVByb3ZpZGVyLl9zZW5kfSwgd2hpY2ggaXMgYWxzbyBjb3BpZWQgb3Zlci5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJlc3VsdChwYXlsb2FkKSB7XHJcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xyXG4gICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xyXG59XG5cbmV4cG9ydCB7IEFsY2hlbXlQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS1wcm92aWRlci05MzI5NTNlNC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js\n"));

/***/ }),

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3d48e6c0.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3d48e6c0.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyWebSocketProvider\": function() { return /* binding */ AlchemyWebSocketProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-32cab09d.js */ \"./node_modules/alchemy-sdk/dist/esm/index-32cab09d.js\");\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ \"./node_modules/@ethersproject/bignumber/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/networks */ \"./node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/providers */ \"./node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _alchemy_provider_932953e4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alchemy-provider-932953e4.js */ \"./node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"./node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                ((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [(0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.t)(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.t)(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber),\r\n                        logIndex: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.t)(fromBlockInclusive), toBlock: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.t)(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = _alchemy_provider_932953e4_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = _alchemy_provider_932953e4_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = _alchemy_provider_932953e4_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.V}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.E[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.n;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.C) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if ((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if ((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.v)(eventName);\r\n            const event = new _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.c((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [..._index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.A, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if ((0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.i)(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.D;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.A.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.A.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.h) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.j.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.k) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.j.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.h:\r\n                return result => this.emit({\r\n                    method: _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.j.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.k:\r\n                return result => this.emit({\r\n                    method: _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.j.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.e)(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket) : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\n\n//# sourceMappingURL=alchemy-websocket-provider-3d48e6c0.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItM2Q0OGU2YzAuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwWjtBQUMzVztBQUNNO0FBQ0E7QUFDUTtBQUNJO0FBQzVDO0FBQ047QUFDMkI7QUFDWDtBQUNHO0FBQ047O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxREFBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQU87QUFDdEMsMkRBQTJELFVBQVUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQU87QUFDeEIsb0JBQW9CLHFEQUFPO0FBQzNCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBLG1CQUFtQixxREFBTztBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBLDZCQUE2QixxREFBSztBQUNsQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0EsOERBQThELHFEQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQSxnQkFBZ0IscURBQUs7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQSx3REFBd0QscURBQU87QUFDL0Q7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxxREFBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFEQUFPO0FBQzVDLGtDQUFrQyxxREFBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEsV0FBVyxxREFBSywrQkFBK0IscURBQUssd0JBQXdCO0FBQ3ZKO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCLEdBQUcsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxlQUFlLFVBQVUsNENBQTRDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1RUFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0ZBQXlCO0FBQ2hEO0FBQ0EsK0JBQStCLDRGQUFpQztBQUNoRSwyQkFBMkIsbUdBQXdDO0FBQ25FLHdDQUF3QyxpREFBTyxDQUFDO0FBQ2hEO0FBQ0EsdUJBQXVCLHdEQUFlO0FBQ3RDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpREFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVELDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw0QkFBNEIscURBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx1QkFBdUI7QUFDN0Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaURBQUk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpREFBYztBQUNwRSxtQkFBbUIsaURBQWM7QUFDakM7QUFDQTtBQUNBLGVBQWUsbUVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQixTQUFTLGlCQUFpQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscURBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFEQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxREFBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxREFBYztBQUMxQixZQUFZLHFEQUFzQjtBQUNsQyw4QkFBOEIsaURBQVcsQ0FBQyxxREFBa0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBbUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxREFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaURBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTRCO0FBQ3hDO0FBQ0EseUNBQXlDLDBEQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEIsb0JBQW9CLDZFQUE2RTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQscURBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlEQUF1QztBQUNsRSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0EsZ0JBQWdCLHNFQUF3QztBQUN4RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGdDQUFnQyxpREFBcUM7QUFDckUsb0JBQW9CLHdDQUF3QztBQUM1RDtBQUNBLGdCQUFnQixvRUFBc0M7QUFDdEQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpREFBdUM7QUFDeEQ7QUFDQSw0QkFBNEIsc0VBQXdDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixpQkFBaUIsaURBQXFDO0FBQ3REO0FBQ0EsNEJBQTRCLG9FQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdDQUF3QyxvRUFBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBa0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQWtCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4RkFBaUM7QUFDbEU7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCLFFBQVEsT0FBTztBQUNmLFFBQVEsT0FBTztBQUNmLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLHFEQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYWxjaGVteS1zZGsvZGlzdC9lc20vYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItM2Q0OGU2YzAuanM/MjMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfIGFzIF9fYXdhaXRlciwgZiBhcyBmcm9tSGV4LCB0IGFzIHRvSGV4LCBuIGFzIG5vb3AsIEMgYXMgQ3VzdG9tTmV0d29ya3MsIGkgYXMgaXNBbGNoZW15RXZlbnQsIHYgYXMgdmVyaWZ5QWxjaGVteUV2ZW50TmFtZSwgYyBhcyBFdGhlcnNFdmVudCwgZSBhcyBnZXRBbGNoZW15RXZlbnRUYWcsIEQgYXMgREVGQVVMVF9BTENIRU1ZX0FQSV9LRVksIEEgYXMgQUxDSEVNWV9FVkVOVF9UWVBFUywgaCBhcyBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUsIGogYXMgQWxjaGVteVN1YnNjcmlwdGlvbiwgayBhcyBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFLCBWIGFzIFZFUlNJT04sIEUgYXMgRXRoZXJzTmV0d29yayB9IGZyb20gJy4vaW5kZXgtMzJjYWIwOWQuanMnO1xuaW1wb3J0IFN0dXJkeVdlYlNvY2tldCBmcm9tICdzdHVyZHktd2Vic29ja2V0JztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvbmV0d29ya3MnO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnO1xuaW1wb3J0IHsgQWxjaGVteVByb3ZpZGVyIH0gZnJvbSAnLi9hbGNoZW15LXByb3ZpZGVyLTkzMjk1M2U0LmpzJztcbmltcG9ydCAnLi9hcGkvdXRpbHMnO1xuaW1wb3J0ICdheGlvcyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3Qvd2FsbGV0JztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3Qvd2ViJztcblxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBibG9ja3MgdG8gYmFja2ZpbGwuIElmIG1vcmUgdGhhbiB0aGlzIG1hbnkgYmxvY2tzIGhhdmVcclxuICogYmVlbiBtaXNzZWQsIHRoZW4gd2UnbGwgc2FkbHkgbWlzcyBkYXRhLCBidXQgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgZG9uJ3RcclxuICogZW5kIHVwIHJlcXVlc3RpbmcgdGhvdXNhbmRzIG9mIGJsb2NrcyBpZiBzb21lYm9keSBsZWZ0IHRoZWlyIGxhcHRvcCBjbG9zZWQgZm9yIGEgd2Vlay5cclxuICovXHJcbmNvbnN0IE1BWF9CQUNLRklMTF9CTE9DS1MgPSAxMjA7XHJcbi8qKlxyXG4gKiBUaGUgV2Vic29ja2V0QmFja2ZpbGxlciBmZXRjaGVzIGV2ZW50cyB0aGF0IHdlcmUgc2VudCBzaW5jZSBhIHByb3ZpZGVkIGJsb2NrXHJcbiAqIG51bWJlci4gVGhpcyBpcyB1c2VkIGluIHRoZSB7QGxpbmsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyfSB0byBiYWNrZmlsbFxyXG4gKiBldmVudHMgdGhhdCB3ZXJlIHRyYW5zbWl0dGVkIHdoaWxlIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3YXMgZG93bi5cclxuICpcclxuICogVGhlIGJhY2tmaWxsZXIgYmFja2ZpbGxzIHR3byBtYWluIGV0aF9zdWJzY3JpYmUgZXZlbnRzOiBgbG9nc2AgYW5kIGBuZXdIZWFkc2AuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgV2Vic29ja2V0QmFja2ZpbGxlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICAvLyBUT0RPOiBVc2UgSFRUUCBwcm92aWRlciB0byBkbyBiYWNrZmlsbC5cclxuICAgICAgICB0aGlzLm1heEJhY2tmaWxsQmxvY2tzID0gTUFYX0JBQ0tGSUxMX0JMT0NLUztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBiYWNrZmlsbCBmb3IgYG5ld0hlYWRzYCBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkIFdoZXRoZXIgdGhlIGJhY2tmaWxsIHJlcXVlc3QgaXMgY2FuY2VsbGVkLlxyXG4gICAgICogQHBhcmFtIHByZXZpb3VzSGVhZHMgUHJldmlvdXMgaGVhZCByZXF1ZXN0cyB0aGF0IHdlcmUgc2VudC5cclxuICAgICAqIEBwYXJhbSBmcm9tQmxvY2tOdW1iZXIgVGhlIGJsb2NrIG51bWJlciB0byBzdGFydCBiYWNrZmlsbGluZyBmcm9tLlxyXG4gICAgICogQHJldHVybnMgQSBsaXN0IG9mIGBuZXdIZWFkc2AgZXZlbnRzIHRoYXQgd2VyZSBzZW50IHNpbmNlIHRoZSBsYXN0IGJhY2tmaWxsLlxyXG4gICAgICovXHJcbiAgICBnZXROZXdIZWFkc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzLCBmcm9tQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgdG9CbG9ja051bWJlciA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwcmV2aW91cyBoZWFkcyB0byBmZXRjaCwgcmV0dXJuIG5ldyBoZWFkcyBzaW5jZVxyXG4gICAgICAgICAgICAvLyBgZnJvbUJsb2NrTnVtYmVyYCwgb3IgdXAgdG8gbWF4QmFja2ZpbGxCbG9ja3MgZnJvbSB0aGUgY3VycmVudCBoZWFkLlxyXG4gICAgICAgICAgICBpZiAocHJldmlvdXNIZWFkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKE1hdGgubWF4KGZyb21CbG9ja051bWJlciwgdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MpICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGVtaXR0ZWQgZXZlbnQgaXMgdG9vIGZhciBiYWNrIGluIHRoZSBwYXN0LCB0aGVyZSdzIG5vIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYmFja2ZpbGwgZm9yIHJlb3Jncy4gSnVzdCBmZXRjaCB0aGUgbGFzdCBgbWF4QmFja2ZpbGxCbG9ja3NgIHdvcnRoIG9mXHJcbiAgICAgICAgICAgIC8vIG5ldyBoZWFkcy5cclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlZW5CbG9ja051bWJlciA9IGZyb21IZXgocHJldmlvdXNIZWFkc1twcmV2aW91c0hlYWRzLmxlbmd0aCAtIDFdLm51bWJlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbkJsb2NrTnVtYmVyID0gdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgKyAxO1xyXG4gICAgICAgICAgICBpZiAobGFzdFNlZW5CbG9ja051bWJlciA8PSBtaW5CbG9ja051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZEV2ZW50c0luUmFuZ2UobWluQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUbyBjYXB0dXJlIGFsbCBgbmV3SGVhZHNgIGV2ZW50cywgcmV0dXJuIGFsbCBoZWFkIGV2ZW50cyBmcm9tIHRoZSBsYXN0XHJcbiAgICAgICAgICAgIC8vIHNlZW4gYmxvY2sgbnVtYmVyIHRvIGN1cnJlbnQgKyBhbnkgb2YgdGhlIHByZXZpb3VzIGhlYWRzIHRoYXQgd2VyZSByZS1vcmdlZC5cclxuICAgICAgICAgICAgY29uc3QgcmVvcmdIZWFkcyA9IHlpZWxkIHRoaXMuZ2V0UmVvcmdIZWFkcyhpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcyk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVIZWFkcyA9IHlpZWxkIHRoaXMuZ2V0SGVhZEV2ZW50c0luUmFuZ2UobGFzdFNlZW5CbG9ja051bWJlciArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbLi4ucmVvcmdIZWFkcywgLi4uaW50ZXJtZWRpYXRlSGVhZHNdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGJhY2tmaWxsIGZvciBgbG9nc2AgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZCBXaGV0aGVyIHRoZSBiYWNrZmlsbCByZXF1ZXN0IGlzIGNhbmNlbGxlZC5cclxuICAgICAqIEBwYXJhbSBmaWx0ZXIgVGhlIGZpbHRlciBvYmplY3QgdGhhdCBhY2NvbXBhbmllcyBhIGxvZ3Mgc3Vic2NyaXB0aW9uLlxyXG4gICAgICogQHBhcmFtIHByZXZpb3VzTG9ncyBQcmV2aW91cyBsb2cgcmVxdWVzdHMgdGhhdCB3ZXJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrTnVtYmVyIFRoZSBibG9jayBudW1iZXIgdG8gc3RhcnQgYmFja2ZpbGxpbmcgZnJvbS5cclxuICAgICAqL1xyXG4gICAgZ2V0TG9nc0JhY2tmaWxsKGlzQ2FuY2VsbGVkLCBmaWx0ZXIsIHByZXZpb3VzTG9ncywgZnJvbUJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgbG9ncyB0byBmZXRjaCwgcmV0dXJuIG5ldyBsb2dzIHNpbmNlXHJcbiAgICAgICAgICAgIC8vIGBmcm9tQmxvY2tOdW1iZXJgLCBvciB1cCB0byBgbWF4QmFja2ZpbGxCbG9ja3NgIGZyb20gdGhlIGN1cnJlbnQgaGVhZC5cclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzTG9ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgTWF0aC5tYXgoZnJvbUJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcykgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgZW1pdHRlZCBsb2cgaXMgdG9vIGZhciBiYWNrIGluIHRoZSBwYXN0LCB0aGVyZSdzIG5vIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYmFja2ZpbGwgZm9yIHJlbW92ZWQgbG9ncy4gSnVzdCBmZXRjaCB0aGUgbGFzdCBgbWF4QmFja2ZpbGxCbG9ja3NgXHJcbiAgICAgICAgICAgIC8vIHdvcnRoIG9mIGxvZ3MuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQmxvY2tOdW1iZXIgPSBmcm9tSGV4KHByZXZpb3VzTG9nc1twcmV2aW91c0xvZ3MubGVuZ3RoIC0gMV0uYmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5CbG9ja051bWJlciA9IHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzICsgMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPCBtaW5CbG9ja051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBtaW5CbG9ja051bWJlciwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJldHVybiBhbGwgbG9nIGV2ZW50cyB0aGF0IGhhdmUgaGFwcGVuZWQgYWxvbmcgd2l0aCBsb2cgZXZlbnRzIHRoYXQgaGF2ZVxyXG4gICAgICAgICAgICAvLyBiZWVuIHJlbW92ZWQgZHVlIHRvIGEgY2hhaW4gcmVvcmcuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbkFuY2VzdG9yID0geWllbGQgdGhpcy5nZXRDb21tb25BbmNlc3Rvcihpc0NhbmNlbGxlZCwgcHJldmlvdXNMb2dzKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIC8vIEFsbCBwcmV2aW91cyBsb2dzIHdpdGggYSBibG9jayBudW1iZXIgZ3JlYXRlciB0aGFuIHRoZSBjb21tb24gYW5jZXN0b3JcclxuICAgICAgICAgICAgLy8gd2VyZSBwYXJ0IG9mIGEgcmUtb3JnLCBzbyBtYXJrIHRoZW0gYXMgc3VjaC5cclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZExvZ3MgPSBwcmV2aW91c0xvZ3NcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIobG9nID0+IGZyb21IZXgobG9nLmJsb2NrTnVtYmVyKSA+IGNvbW1vbkFuY2VzdG9yLmJsb2NrTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgLm1hcChsb2cgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nKSwgeyByZW1vdmVkOiB0cnVlIH0pKSk7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGNvbW1vbiBhbmNlc3RvciB3YXMgZm91bmQsIHN0YXJ0IGJhY2tmaWxsIGZyb20gdGhlIG9sZGVzdCBsb2cnc1xyXG4gICAgICAgICAgICAvLyBibG9jayBudW1iZXIuXHJcbiAgICAgICAgICAgIGNvbnN0IGZyb21CbG9ja0luY2x1c2l2ZSA9IGNvbW1vbkFuY2VzdG9yLmJsb2NrTnVtYmVyID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgICAgICAgICAgICAgID8gZnJvbUhleChwcmV2aW91c0xvZ3NbMF0uYmxvY2tOdW1iZXIpXHJcbiAgICAgICAgICAgICAgICA6IGNvbW1vbkFuY2VzdG9yLmJsb2NrTnVtYmVyO1xyXG4gICAgICAgICAgICBsZXQgYWRkZWRMb2dzID0geWllbGQgdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICAvLyBEZS1kdXBlIGFueSBsb2dzIHRoYXQgd2VyZSBhbHJlYWR5IGVtaXR0ZWQuXHJcbiAgICAgICAgICAgIGFkZGVkTG9ncyA9IGFkZGVkTG9ncy5maWx0ZXIobG9nID0+IGxvZyAmJlxyXG4gICAgICAgICAgICAgICAgKGZyb21IZXgobG9nLmJsb2NrTnVtYmVyKSA+IGNvbW1vbkFuY2VzdG9yLmJsb2NrTnVtYmVyIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbUhleChsb2cubG9nSW5kZXgpID4gY29tbW9uQW5jZXN0b3IubG9nSW5kZXgpKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBbLi4ucmVtb3ZlZExvZ3MsIC4uLmFkZGVkTG9nc107XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBuZXcgbWF4IGJhY2tmaWxsIGJsb2Nrcy4gVklTSUJMRSBPTkxZIEZPUiBURVNUSU5HLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzZXRNYXhCYWNrZmlsbEJsb2NrKG5ld01heCkge1xyXG4gICAgICAgIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MgPSBuZXdNYXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgYmxvY2sgbnVtYmVyIGFzIGEgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrTnVtYmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVySGV4ID0geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKCdldGhfYmxvY2tOdW1iZXInKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgoYmxvY2tOdW1iZXJIZXgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCBgbmV3SGVhZGAgZXZlbnRzIGluIHRoZSBwcm92aWRlZCByYW5nZS4gTm90ZSB0aGF0IHRoZSByZXR1cm5lZFxyXG4gICAgICogaGVhZHMgZG8gbm90IGluY2x1ZGUgcmUtb3JnZWQgaGVhZHMuIFVzZSB7QGxpbmsgZ2V0UmVvcmdIZWFkc30gdG8gZmluZCBoZWFkc1xyXG4gICAgICogdGhhdCB3ZXJlIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0SGVhZEV2ZW50c0luUmFuZ2UoZnJvbUJsb2NrSW5jbHVzaXZlLCB0b0Jsb2NrRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21CbG9ja0luY2x1c2l2ZSA+PSB0b0Jsb2NrRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYmF0Y2hQYXJ0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbUJsb2NrSW5jbHVzaXZlOyBpIDwgdG9CbG9ja0V4Y2x1c2l2ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaFBhcnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt0b0hleChpKSwgZmFsc2VdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgZXJyb3JzXHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrSGVhZHMgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRCYXRjaChiYXRjaFBhcnRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJsb2NrSGVhZHMubWFwKHRvTmV3SGVhZHNFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGhlYWRzIHRoYXQgd2VyZSBwYXJ0IG9mIGEgcmVvcmcgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0UmVvcmdIZWFkcyhpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAvLyBJdGVyYXRlIGZyb20gdGhlIG1vc3QgcmVjZW50IGhlYWQgYmFja3dhcmRzIGluIG9yZGVyIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIC8vIGJsb2NrIHRoYXQgd2FzIHBhcnQgb2YgYSByZS1vcmcuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwcmV2aW91c0hlYWRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudCA9IHByZXZpb3VzSGVhZHNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja0hlYWQgPSB5aWVsZCB0aGlzLmdldEJsb2NrQnlOdW1iZXIoZnJvbUhleChvbGRFdmVudC5udW1iZXIpKTtcclxuICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGhhc2hlcyBtYXRjaCwgdGhlbiBjdXJyZW50IGhlYWQgaW4gdGhlIGl0ZXJhdGlvbiB3YXMgbm90IHJlLW9yZ2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50Lmhhc2ggPT09IGJsb2NrSGVhZC5oYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b05ld0hlYWRzRXZlbnQoYmxvY2tIZWFkKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSB3cmFwcGVyIGFyb3VuZCBgZXRoX2dldEJsb2NrQnlOdW1iZXJgIHRoYXQgcmV0dXJucyB0aGUgY29tcGxldGVcclxuICAgICAqIGJsb2NrIGluZm9ybWF0aW9uIGZvciB0aGUgcHJvdmlkZWQgYmxvY2sgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEJsb2NrQnlOdW1iZXIoYmxvY2tOdW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKCdldGhfZ2V0QmxvY2tCeU51bWJlcicsIFtcclxuICAgICAgICAgICAgICAgIHRvSGV4KGJsb2NrTnVtYmVyKSxcclxuICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGxpc3Qgb2YgcHJldmlvdXMgbG9nIGV2ZW50cywgZmluZHMgdGhlIGNvbW1vbiBibG9jayBudW1iZXIgZnJvbSB0aGVcclxuICAgICAqIGxvZ3MgdGhhdCBtYXRjaGVzIHRoZSBibG9jayBoZWFkLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgd2hpY2ggbG9ncyBhcmUgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm5zIDEgbGVzcyB0aGFuIHRoZSBvbGRlc3QgbG9nJ3MgYmxvY2sgbnVtYmVyIGlmIG5vIGNvbW1vbiBhbmNlc3RvciB3YXMgZm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q29tbW9uQW5jZXN0b3IoaXNDYW5jZWxsZWQsIHByZXZpb3VzTG9ncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgZnJvbSB0aGUgbW9zdCByZWNlbnQgaGVhZCBiYWNrd2FyZHMgaW4gb3JkZXIgdG8gZmluZCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgLy8gYmxvY2sgdGhhdCB3YXMgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAgICAgICAgbGV0IGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KHByZXZpb3VzTG9nc1twcmV2aW91c0xvZ3MubGVuZ3RoIC0gMV0uYmxvY2tOdW1iZXIpKTtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBwcmV2aW91c0xvZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZExvZyA9IHByZXZpb3VzTG9nc1tpXTtcclxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IHVwZGF0ZWQgYmxvY2tzIGFyZSBmZXRjaGVkIGV2ZXJ5IHRpbWUgdGhlIGxvZydzIGJsb2NrIG51bWJlclxyXG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgIGlmIChvbGRMb2cuYmxvY2tOdW1iZXIgIT09IGJsb2NrSGVhZC5udW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0hlYWQgPSB5aWVsZCB0aGlzLmdldEJsb2NrQnlOdW1iZXIoZnJvbUhleChvbGRMb2cuYmxvY2tOdW1iZXIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIGxvZ3MgYXJlIG9yZGVyZWQgaW4gYXNjZW5kaW5nIG9yZGVyLCB0aGUgZmlyc3QgbG9nIHRoYXQgbWF0Y2hlc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGhhc2ggc2hvdWxkIGJlIHRoZSBsYXJnZXN0IGxvZ0luZGV4LlxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZExvZy5ibG9ja0hhc2ggPT09IGJsb2NrSGVhZC5oYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IGZyb21IZXgob2xkTG9nLmJsb2NrTnVtYmVyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nSW5kZXg6IGZyb21IZXgob2xkTG9nLmxvZ0luZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXHJcbiAgICAgICAgICAgICAgICBsb2dJbmRleDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIGBsb2dzYCBldmVudHMgaW4gdGhlIHByb3ZpZGVkIHJhbmdlLiBOb3RlIHRoYXQgdGhlIHJldHVybmVkIGxvZ3NcclxuICAgICAqIGRvIG5vdCBpbmNsdWRlIHJlbW92ZWQgbG9ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovIGdldExvZ3NJblJhbmdlKGZpbHRlciwgZnJvbUJsb2NrSW5jbHVzaXZlLCB0b0Jsb2NrRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKGZyb21CbG9ja0luY2x1c2l2ZSA+PSB0b0Jsb2NrRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmFuZ2VGaWx0ZXIgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZpbHRlciksIHsgZnJvbUJsb2NrOiB0b0hleChmcm9tQmxvY2tJbmNsdXNpdmUpLCB0b0Jsb2NrOiB0b0hleCh0b0Jsb2NrRXhjbHVzaXZlIC0gMSkgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRMb2dzJywgW3JhbmdlRmlsdGVyXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdG9OZXdIZWFkc0V2ZW50KGhlYWQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIGhlYWQpO1xyXG4gICAgZGVsZXRlIHJlc3VsdC50b3RhbERpZmZpY3VsdHk7XHJcbiAgICBkZWxldGUgcmVzdWx0LnRyYW5zYWN0aW9ucztcclxuICAgIGRlbGV0ZSByZXN1bHQudW5jbGVzO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBkZWR1cGVOZXdIZWFkcyhldmVudHMpIHtcclxuICAgIHJldHVybiBkZWR1cGUoZXZlbnRzLCBldmVudCA9PiBldmVudC5oYXNoKTtcclxufVxyXG5mdW5jdGlvbiBkZWR1cGVMb2dzKGV2ZW50cykge1xyXG4gICAgcmV0dXJuIGRlZHVwZShldmVudHMsIGV2ZW50ID0+IGAke2V2ZW50LmJsb2NrSGFzaH0vJHtldmVudC5sb2dJbmRleH1gKTtcclxufVxyXG5mdW5jdGlvbiBkZWR1cGUoaXRlbXMsIGdldEtleSkge1xyXG4gICAgY29uc3Qga2V5c1NlZW4gPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5KGl0ZW0pO1xyXG4gICAgICAgIGlmICgha2V5c1NlZW4uaGFzKGtleSkpIHtcclxuICAgICAgICAgICAga2V5c1NlZW4uYWRkKGtleSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBDQU5DRUxMRUQgPSBuZXcgRXJyb3IoJ0NhbmNlbGxlZCcpO1xyXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKSB7XHJcbiAgICBpZiAoaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgIHRocm93IENBTkNFTExFRDtcclxuICAgIH1cclxufVxuXG5jb25zdCBIRUFSVEJFQVRfSU5URVJWQUwgPSAzMDAwMDtcclxuY29uc3QgSEVBUlRCRUFUX1dBSVRfVElNRSA9IDEwMDAwO1xyXG5jb25zdCBCQUNLRklMTF9USU1FT1VUID0gNjAwMDA7XHJcbmNvbnN0IEJBQ0tGSUxMX1JFVFJJRVMgPSA1O1xyXG4vKipcclxuICogU3Vic2NyaXB0aW9ucyBoYXZlIGEgbWVtb3J5IG9mIHJlY2VudCBldmVudHMgdGhleSBoYXZlIHNlbnQgc28gdGhhdCBpbiB0aGVcclxuICogZXZlbnQgdGhhdCB0aGV5IGRpc2Nvbm5lY3QgYW5kIG5lZWQgdG8gYmFja2ZpbGwsIHRoZXkgY2FuIGRldGVjdCByZS1vcmdzLlxyXG4gKiBLZWVwIGEgYnVmZmVyIHRoYXQgZ29lcyBiYWNrIGF0IGxlYXN0IHRoZXNlIG1hbnkgYmxvY2tzLCB0aGUgbWF4aW11bSBhbW91bnRcclxuICogYXQgd2hpY2ggd2UgbWlnaHQgY29uY2VpdmFibHkgc2VlIGEgcmUtb3JnLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgd2hpbGUgb3VyIGJ1ZmZlciBnb2VzIGJhY2sgdGhpcyBtYW55IGJsb2NrcywgaXQgbWF5IGNvbnRhaW4gbW9yZVxyXG4gKiB0aGFuIHRoaXMgbWFueSBlbGVtZW50cywgc2luY2UgaW4gdGhlIGNhc2Ugb2YgbG9ncyBzdWJzY3JpcHRpb25zIG1vcmUgdGhhblxyXG4gKiBvbmUgZXZlbnQgbWF5IGJlIGVtaXR0ZWQgZm9yIGEgYmxvY2suXHJcbiAqL1xyXG5jb25zdCBSRVRBSU5FRF9FVkVOVF9CTE9DS19DT1VOVCA9IDEwO1xyXG4vKipcclxuICogU0RLJ3MgY3VzdG9tIGltcGxlbWVudGF0aW9uIGZvIHRoZSBldGhlcnMuanMncyAnQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyJy5cclxuICpcclxuICogRG8gbm90IGNhbGwgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gSW5zdGVhZCwgaW5zdGFudGlhdGUgYW4gaW5zdGFuY2Ugb2ZcclxuICoge0BsaW5rIEFsY2hlbXl9IGFuZCBjYWxsIHtAbGluayBBbGNoZW15LmNvbmZpZy5nZXRXZWJTb2NrZXRQcm92aWRlcigpfS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY2xhc3MgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgV2ViU29ja2V0UHJvdmlkZXIge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCB3c0NvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQVBJIEtleSB0byBhIHN0cmluZy5cclxuICAgICAgICBjb25zdCBhcGlLZXkgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QXBpS2V5KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIC8vIEdlbmVyYXRlIG91ciBvd24gY29ubmVjdGlvbiBpbmZvIHdpdGggdGhlIGNvcnJlY3QgZW5kcG9pbnQgVVJMcy5cclxuICAgICAgICBjb25zdCBhbGNoZW15TmV0d29yayA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15TmV0d29yayhjb25maWcubmV0d29yayk7XHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEFsY2hlbXlQcm92aWRlci5nZXRBbGNoZW15Q29ubmVjdGlvbkluZm8oYWxjaGVteU5ldHdvcmssIGFwaUtleSwgJ3dzcycpO1xyXG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gYGFsY2hlbXktc2RrLSR7VkVSU0lPTn1gO1xyXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgY29uZmlnIFVSTCBvdmVycmlkZSBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIGNyZWF0ZWQgb25lLlxyXG4gICAgICAgIGNvbnN0IHdzID0gbmV3IFN0dXJkeVdlYlNvY2tldCgoX2EgPSBjb25maWcudXJsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25uZWN0aW9uLnVybCwgcHJvdG9jb2wsIHtcclxuICAgICAgICAgICAgd3NDb25zdHJ1Y3Rvcjogd3NDb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiB3c0NvbnN0cnVjdG9yICE9PSB2b2lkIDAgPyB3c0NvbnN0cnVjdG9yIDogZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIod3MsIGV0aGVyc05ldHdvcmspO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xyXG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgV2ViU29ja2V0IHJlY29ubmVjdGlvbiwgYWxsIHN1YnNjcmlwdGlvbnMgYXJlIGxvc3QgYW5kIHdlXHJcbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvbmVzIHRvIHJlcGxhY2UgdGhlbSwgYnV0IHdlIHdhbnQgdG8gY3JlYXRlIHRoZSBpbGx1c2lvbiB0aGF0XHJcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIHN1YnNjcmlwdGlvbnMgcGVyc2lzdC4gVGh1cywgbWFpbnRhaW4gYSBtYXBwaW5nIGZyb20gdGhlXHJcbiAgICAgICAgLy8gXCJ2aXJ0dWFsXCIgc3Vic2NyaXB0aW9uIGlkcyB3aGljaCBhcmUgdmlzaWJsZSB0byB0aGUgY29uc3VtZXIgdG8gdGhlXHJcbiAgICAgICAgLy8gXCJwaHlzaWNhbFwiIHN1YnNjcmlwdGlvbiBpZHMgb2YgdGhlIGFjdHVhbCBjb25uZWN0aW9ucy4gVGhpcyB0ZXJtaW5vbG9neSBpc1xyXG4gICAgICAgIC8vIGJvcnJvd2VkIGZyb20gdmlydHVhbCBhbmQgcGh5c2ljYWwgbWVtb3J5LCB3aGljaCBoYXMgYSBzaW1pbGFyIG1hcHBpbmcuXHJcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgICAgIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgZXRoZXJzIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn0gYWxyZWFkeSBoYW5kbGVzIGFuZCBlbWl0c1xyXG4gICAgICAgICAqIG1lc3NhZ2VzLiBUbyBhbGxvdyBiYWNrZmlsbGluZywgdHJhY2sgYWxsIG1lc3NhZ2VzIHRoYXQgYXJlIGVtaXR0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBUaGlzIGlzIGEgZmllbGQgYXJyb3cgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcHJlc2VydmUgYHRoaXNgIGNvbnRleHQgd2hlblxyXG4gICAgICAgICAqIHBhc3NpbmcgdGhlIG1ldGhvZCBhcyBhbiBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFpc1N1YnNjcmlwdGlvbkV2ZW50KG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcGh5c2ljYWxJZCA9IG1lc3NhZ2UucGFyYW1zLnN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgdmlydHVhbElkID0gdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLmdldChwaHlzaWNhbElkKTtcclxuICAgICAgICAgICAgaWYgKCF2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5nZXQodmlydHVhbElkKTtcclxuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5tZXRob2QgIT09ICdldGhfc3Vic2NyaWJlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uLnBhcmFtc1swXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3SGVhZHMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGVhZHNTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SGVhZHNNZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlzQmFja2ZpbGxpbmcsIGJhY2tmaWxsQnVmZmVyIH0gPSBuZXdIZWFkc1N1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbmV3SGVhZHNNZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKGJhY2tmaWxsQnVmZmVyLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwaHlzaWNhbElkICE9PSB2aXJ0dWFsSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSByZS1vcGVuZWQgc3Vic2NyaXB0aW9uLCBldGhlcnMgd2lsbCBub3QgZW1pdCB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbnQsIHNvIHRoZSBTREsgaGFzIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV0aGVycyBzdWJzY3JpcHRpb24gbWFwcGluZyB3aWxsIGVtaXQgdGhlIGV2ZW50LCBqdXN0IHN0b3JlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2dzTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc0JhY2tmaWxsaW5nLCBiYWNrZmlsbEJ1ZmZlciB9ID0gbG9nc1N1YnNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gbG9nc01lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0JhY2tmaWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmlydHVhbElkICE9PSBwaHlzaWNhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdEFuZFJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldExvZ3NCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGh5c2ljYWxJZCAhPT0gdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcmUtb3BlbmVkIHN1YnNjcmlwdGlvbiwgZXRoZXJzIHdpbGwgbm90IGVtaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LCBzbyB0aGUgU0RLIGhhcyB0by5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IG1lc3NhZ2UucGFyYW1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiByZW9wZW5zOlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogMS4gUmVzdWJzY3JpYmUgdG8gYWxsIGV4aXN0aW5nIHN1YnNjcmlwdGlvbnMgYW5kIHN0YXJ0IGJhY2tmaWxsaW5nXHJcbiAgICAgICAgICogMi4gUmVzdGFydCBoZWFydCBiZWF0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhbmRsZVJlb3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2FuY2VsLCBpc0NhbmNlbGxlZCB9ID0gbWFrZUNhbmNlbFRva2VuKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwgPSBjYW5jZWw7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3Vic2NyaXB0aW9uIG9mIHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB2b2lkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZXN1YnNjcmliZUFuZEJhY2tmaWxsKGlzQ2FuY2VsbGVkLCBzdWJzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGlsZSBiYWNrZmlsbGluZyBcIiR7c3Vic2NyaXB0aW9uLnBhcmFtc1swXX1cIiBzdWJzY3JpcHRpb24uIFNvbWUgZXZlbnRzIG1heSBiZSBtaXNzaW5nLmAsIGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRIZWFydGJlYXQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbmNlbHMgdGhlIGhlYXJ0YmVhdCBhbmQgYW55IHBlbmRpbmcgYmFja2ZpbGxzIGJlaW5nIHBlcmZvcm1lZC4gVGhpcyBpc1xyXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBnb2VzIGRvd24gb3IgaXMgZGlzY29ubmVjdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XHJcbiAgICAgICAgLy8gU3RhcnQgaGVhcnRiZWF0IGFuZCBiYWNrZmlsbGVyIGZvciB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24uXHJcbiAgICAgICAgdGhpcy5iYWNrZmlsbGVyID0gbmV3IFdlYnNvY2tldEJhY2tmaWxsZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGRTb2NrZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxCYWNrZmlsbCA9IG5vb3A7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYEJhc2VQcm92aWRlci5nZXROZXR3b3JrYCBtZXRob2QgYXMgaW1wbGVtZW50ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgb3ZlcnJpZGUgYWxsb3dzIHRoZSBTREsgdG8gc2V0IHRoZSBwcm92aWRlcidzIG5ldHdvcmsgdG8gdmFsdWVzIG5vdFxyXG4gICAgICogeWV0IHN1cHBvcnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ3N0cmluZycgJiYgbmV0d29yayBpbiBDdXN0b21OZXR3b3Jrcykge1xyXG4gICAgICAgICAgICByZXR1cm4gQ3VzdG9tTmV0d29ya3NbbmV0d29ya107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENhbGwgdGhlIHN0YW5kYXJkIGV0aGVycy5qcyBnZXROZXR3b3JrIG1ldGhvZCBmb3Igb3RoZXIgbmV0d29ya3MuXHJcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsobmV0d29yayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gaW1wbGVtZW50YXRpb24gb2YgZXRoZXJzIHRoYXQgaW5jbHVkZXMgQWxjaGVteSBiYXNlZCBzdWJzY3JpcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IE92ZXJyaWRlIGBMaXN0ZW5lcmAgdHlwZSB0byBnZXQgdHlwZSBhdXRvY29tcGxldGlvbnMuXHJcbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycyB0aGF0IGluY2x1ZGVzIEFsY2hlbXkgYmFzZWRcclxuICAgICAqIHN1YnNjcmlwdGlvbnMuIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgdHJpZ2dlcmVkIGZvciBvbmx5IHRoZSBuZXh0XHJcbiAgICAgKiB7QGxpbmsgZXZlbnROYW1lfSBldmVudCwgYWZ0ZXIgd2hpY2ggaXQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gc3Vic2NyaWJlIHRvXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIC8vIFRPRE86IE92ZXJyaWRlIGBMaXN0ZW5lcmAgdHlwZSB0byBnZXQgdHlwZSBhdXRvY29tcGxldGlvbnMuXHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvdmlkZWQge0BsaW5rIGxpc3RlbmVyfSBmb3IgdGhlIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBub1xyXG4gICAgICogbGlzdGVuZXIgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBldmVudCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBFdmVudCB0byB1bmxpc3RlbiB0by5cclxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZiBubyBldmVudFxyXG4gICAgICogaXMgcHJvdmlkZWQsIGFsbCBldmVudHMgYW5kIHRoZWlyIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCB0aGUgdG90YWwgbnVtYmVyIG9mIGxpc3RlbmVycyBmb3IgYWxsIGV2ZW50cyBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gdW5kZWZpbmVkICYmIGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVyQ291bnQoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyBmb3IgdGhlIHByb3ZpZGVkIHtAbGluayBldmVudE5hbWV9IGV2ZW50LiBJZlxyXG4gICAgICogbm8gZXZlbnQgaXMgcHJvdmlkZWQsIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZSBpbmNsdWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBldmVudCB0byBnZXQgdGhlIGxpc3RlbmVycyBmb3IuXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWV0aG9kIGluIGBCYXNlUHJvdmlkZXJgIGluIG9yZGVyIHRvIHByb3Blcmx5IGZvcm1hdCB0aGVcclxuICAgICAqIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XHJcbiAgICAgICAgaWYgKGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgdmVyaWZ5QWxjaGVteUV2ZW50TmFtZShldmVudE5hbWUpO1xyXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdGhlcnNFdmVudChnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKSwgbGlzdGVuZXIsIG9uY2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYF9zdGFydEV2ZW50KClgIG1ldGhvZCBpbiBldGhlcnMuanMnc1xyXG4gICAgICoge0BsaW5rIFdlYlNvY2tldFByb3ZpZGVyfSB0byBpbmNsdWRlIGFkZGl0aW9uYWwgYWxjaGVteSBtZXRob2RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXZlbnQgdHlwZSBpcyBhIGN1c3RvbSBBbGNoZW15IHN1YnNjcmlwdGlvbi5cclxuICAgICAgICBjb25zdCBjdXN0b21Mb2dpY1R5cGVzID0gWy4uLkFMQ0hFTVlfRVZFTlRfVFlQRVMsICdibG9jaycsICdmaWx0ZXInXTtcclxuICAgICAgICBpZiAoY3VzdG9tTG9naWNUeXBlcy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVN0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3VwZXIuX3N0YXJ0RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBmcm9tIGV0aGVycy5qcydzIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn1cclxuICAgICAqXHJcbiAgICAgKiBNb2RpZmllZCBpbiBvcmRlciB0byBhZGQgbWFwcGluZ3MgZm9yIGJhY2tmaWxsaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMsIGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IHN1YklkUHJvbWlzZSA9IHRoaXMuX3N1Yklkc1t0YWddO1xyXG4gICAgICAgICAgICAvLyBCRUdJTiBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0aW5nQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViSWRQcm9taXNlID0gUHJvbWlzZS5hbGwocGFyYW0pLnRoZW4ocGFyYW0gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQoJ2V0aF9zdWJzY3JpYmUnLCBwYXJhbSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1Yklkc1t0YWddID0gc3ViSWRQcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN1YklkID0geWllbGQgc3ViSWRQcm9taXNlO1xyXG4gICAgICAgICAgICAvLyBCRUdJTiBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUGFyYW1zID0geWllbGQgUHJvbWlzZS5hbGwocGFyYW0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC5zZXQoc3ViSWQsIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudCxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9zdWJzY3JpYmUnLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiByZXNvbHZlZFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN0YXJ0aW5nQmxvY2tOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICB2aXJ0dWFsSWQ6IHN1YklkLFxyXG4gICAgICAgICAgICAgICAgcGh5c2ljYWxJZDogc3ViSWQsXHJcbiAgICAgICAgICAgICAgICBzZW50RXZlbnRzOiBbXSxcclxuICAgICAgICAgICAgICAgIGlzQmFja2ZpbGxpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXI6IFtdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnZpcnR1YWxJZHNCeVBoeXNpY2FsSWQuc2V0KHN1YklkLCBzdWJJZCk7XHJcbiAgICAgICAgICAgIC8vIEVORCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gaW1wbGVtZW50IEFsY2hlbXkncyB1bmlxdWVcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlcy4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGF0IHRoaXMgbWV0aG9kIGNhbGxzXHJcbiAgICAgKiB7QGxpbmsgZ2V0QWxjaGVteUV2ZW50VGFnfSBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBgZ2V0RXZlbnRUYWcoKWAgbWV0aG9kIGluXHJcbiAgICAgKiBvcmRlciB0byBwYXJzZSB0aGUgQWxjaGVteSBzdWJzY3JpcHRpb24gZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAoaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcclxuICAgICAgICAgICAgLy8gVGhpcyBsaW5lIGlzIHRoZSBvbmx5IG1vZGlmaWVkIGxpbmUgZnJvbSB0aGUgb3JpZ2luYWwgbWV0aG9kLlxyXG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50TmFtZSwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgc2VuZEJhdGNoKHBhcnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgbGV0IG5leHRJZCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJ0cy5tYXAoKHsgbWV0aG9kLCBwYXJhbXMgfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBgYWxjaGVteS1zZGs6JHtuZXh0SWQrK31gXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJhdGNoQ29uY3VycmVudGx5KHBheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNvY2tldExpc3RlbmVycygpO1xyXG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdEFuZEJhY2tmaWxsKCk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBldGhlcidzIGBpc0NvbW11bml0eVJlc291cmNlKClgIG1ldGhvZC4gUmV0dXJucyB0cnVlIGlmIHRoZVxyXG4gICAgICogY3VycmVudCBhcGkga2V5IGlzIHRoZSBkZWZhdWx0IGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hcGlLZXkgPT09IERFRkFVTFRfQUxDSEVNWV9BUElfS0VZO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBXZWJTb2NrZXRQcm92aWRlci5fc3RvcEV2ZW50KClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIHN1cHBvcnQgQWxjaGVteSdzXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZSBieSBhbGxvd2luZyB0aGUgcHJvdmlkZXIgdG8gcHJvcGVybHkgc3RvcCBBbGNoZW15J3NcclxuICAgICAqIHN1YnNjcmlwdGlvbiBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBsZXQgdGFnID0gZXZlbnQudGFnO1xyXG4gICAgICAgIC8vIFNUQVJUIE1PRElGSUVEIENPREVcclxuICAgICAgICBpZiAoQUxDSEVNWV9FVkVOVF9UWVBFUy5pbmNsdWRlcyhldmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHBlbmRpbmcgdHJhbnNhY3Rpb24gbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihlID0+IEFMQ0hFTVlfRVZFTlRfVFlQRVMuaW5jbHVkZXMoZS50eXBlKSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3R4Jykge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3R4JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFnID0gJ3R4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFzdWJJZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICB2b2lkIHN1YklkLnRoZW4oc3ViSWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YnNbc3ViSWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNbc3ViSWRdO1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuc2VuZCgnZXRoX3Vuc3Vic2NyaWJlJywgW3N1YklkXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhZGRTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlb3BlbnMgdGhlIGJhY2tmaWxsIGJhc2VkIG9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2aXJ0dWFsSWQsIG1ldGhvZCwgcGFyYW1zLCBzZW50RXZlbnRzLCBiYWNrZmlsbEJ1ZmZlciwgc3RhcnRpbmdCbG9ja051bWJlciB9ID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaHlzaWNhbElkID0geWllbGQgdGhpcy5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnBoeXNpY2FsSWQgPSBwaHlzaWNhbElkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChwaHlzaWNhbElkLCB2aXJ0dWFsSWQpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldE5ld0hlYWRzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHNlbnRFdmVudHMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIpLCBCQUNLRklMTF9USU1FT1VUKSwgQkFDS0ZJTExfUkVUUklFUywgKCkgPT4gIWlzQ2FuY2VsbGVkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGVkdXBlTmV3SGVhZHMoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHBhcmFtc1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCksIEJBQ0tGSUxMX1JFVFJJRVMsICgpID0+ICFpc0NhbmNlbGxlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGRlZHVwZUxvZ3MoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXRMb2dzRXZlbnQodmlydHVhbElkLCBldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdE5ld0hlYWRzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRMb2dzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCB0byBjb25zdW1lcnMsIGJ1dCBhbHNvIHJlbWVtYmVycyBpdCBpbiBpdHMgc3Vic2NyaXB0aW9ucydzXHJcbiAgICAgKiBgc2VudEV2ZW50c2AgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRldGVjdCByZS1vcmdzIGlmIHRoZSBjb25uZWN0aW9uIGRyb3BzXHJcbiAgICAgKiBhbmQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpO1xyXG4gICAgICAgIHRoaXMuZW1pdEV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIGVtaXRFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCkge1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0R2VuZXJpY0V2ZW50KHN1YnNjcmlwdGlvbiwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZWIzIG1vZGlmaWVzIHRoZXNlIGV2ZW50IG9iamVjdHMgb25jZSB3ZSBwYXNzIHRoZW0gb24gKGNoYW5naW5nIGhleFxyXG4gICAgICAgIC8vIG51bWJlcnMgdG8gbnVtYmVycykuIFdlIHdhbnQgdGhlIG9yaWdpbmFsIGV2ZW50LCBzbyBtYWtlIGEgZGVmZW5zaXZlXHJcbiAgICAgICAgLy8gY29weS5cclxuICAgICAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIoc3Vic2NyaXB0aW9uLnNlbnRFdmVudHMsIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIGdldEJsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRHZW5lcmljRXZlbnQoc3Vic2NyaXB0aW9uLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBlbWl0RnVuY3Rpb24gPSB0aGlzLmVtaXRQcm9jZXNzRm4oc3Vic2NyaXB0aW9uLmV2ZW50KTtcclxuICAgICAgICBlbWl0RnVuY3Rpb24ocmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgaGVhcnRiZWF0IHRoYXQgcGluZ3MgdGhlIHdlYnNvY2tldCBzZXJ2ZXIgcGVyaW9kaWNhbGx5IHRvIGVuc3VyZVxyXG4gICAgICogdGhhdCB0aGUgY29ubmVjdGlvbiBzdGF5cyBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGFydEhlYXJ0YmVhdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB3aXRoVGltZW91dCh0aGlzLnNlbmQoJ25ldF92ZXJzaW9uJyksIEhFQVJUQkVBVF9XQUlUX1RJTUUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIEhFQVJUQkVBVF9JTlRFUlZBTCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHNlbmRzIHRoZSBiYXRjaCBjb25jdXJyZW50bHkgYXMgaW5kaXZpZHVhbCByZXF1ZXN0cyByYXRoZXIgdGhhblxyXG4gICAgICogYXMgYSBiYXRjaCwgd2hpY2ggd2FzIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi4gVGhlIG9yaWdpbmFsIGJhdGNoIGxvZ2ljXHJcbiAgICAgKiBpcyBwcmVzZXJ2ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbiBpbiBvcmRlciBmb3IgZmFzdGVyIHBvcnRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBheWxvYWRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPKGNsZWFudXApOiBSZWZhY3RvciBhbmQgcmVtb3ZlIHVzYWdlcyBvZiBgc2VuZEJhdGNoKClgLlxyXG4gICAgLy8gVE9ETyhlcnJvcnMpOiBVc2UgYWxsU2V0dGxlZCgpIG9uY2Ugd2UgaGF2ZSBtb3JlIGVycm9yIGhhbmRsaW5nLlxyXG4gICAgc2VuZEJhdGNoQ29uY3VycmVudGx5KHBheWxvYWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGF5bG9hZC5tYXAocmVxID0+IHRoaXMuc2VuZChyZXEubWV0aG9kLCByZXEucGFyYW1zKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY3VzdG9tU3RhcnRFdmVudChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXHJcbiAgICAgICAgICAgICAgICBBbGNoZW15U3Vic2NyaXB0aW9uLlBFTkRJTkdfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH1cclxuICAgICAgICAgICAgXSwgdGhpcy5lbWl0UHJvY2Vzc0ZuKGV2ZW50KSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVudC50eXBlID09PSBBTENIRU1ZX01JTkVEX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzc2VzLCBpbmNsdWRlUmVtb3ZlZCwgaGFzaGVzT25seSB9ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1xyXG4gICAgICAgICAgICAgICAgQWxjaGVteVN1YnNjcmlwdGlvbi5NSU5FRF9UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICB7IGFkZHJlc3NlcywgaW5jbHVkZVJlbW92ZWQsIGhhc2hlc09ubHkgfVxyXG4gICAgICAgICAgICBdLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdibG9jaycpIHtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoJ2Jsb2NrJywgWyduZXdIZWFkcyddLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdmaWx0ZXInKSB7XHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgWydsb2dzJywgdGhpcy5fZ2V0RmlsdGVyKGV2ZW50LmZpbHRlcildLCB0aGlzLmVtaXRQcm9jZXNzRm4oZXZlbnQpLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdFByb2Nlc3NGbihldmVudCkge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4gdGhpcy5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IEFsY2hlbXlTdWJzY3JpcHRpb24uUEVORElOR19UUkFOU0FDVElPTlMsXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbUFkZHJlc3M6IGV2ZW50LmZyb21BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvQWRkcmVzczogZXZlbnQudG9BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hlc09ubHk6IGV2ZW50Lmhhc2hlc09ubHlcclxuICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XHJcbiAgICAgICAgICAgIGNhc2UgQUxDSEVNWV9NSU5FRF9UUkFOU0FDVElPTlNfRVZFTlRfVFlQRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4gdGhpcy5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IEFsY2hlbXlTdWJzY3JpcHRpb24uTUlORURfVFJBTlNBQ1RJT05TLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NlczogZXZlbnQuYWRkcmVzc2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVSZW1vdmVkOiBldmVudC5pbmNsdWRlUmVtb3ZlZCxcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXNPbmx5OiBldmVudC5oYXNoZXNPbmx5XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICBjYXNlICdibG9jayc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYmxvY2snLCBibG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlIHRvIGBlbWl0UHJvY2Vzc0ZuKClgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIub2ZmKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLnJlbW92ZUFsbExpc3RlbmVycygpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5saXN0ZW5lckNvdW50KClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRhZyA9PT0gZXZlbnRUYWc7XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIubGlzdGVuZXJzKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGV2ZW50ID0+IGV2ZW50Lmxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT4gZXZlbnQudGFnID09PSBldmVudFRhZylcclxuICAgICAgICAgICAgLm1hcChldmVudCA9PiBldmVudC5saXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKSB7XHJcbiAgICByZXR1cm4gaXNOb2RlRW52aXJvbm1lbnQoKSA/IHJlcXVpcmUoJ3dlYnNvY2tldCcpLnczY3dlYnNvY2tldCA6IFdlYlNvY2tldDtcclxufVxyXG5mdW5jdGlvbiBpc05vZGVFbnZpcm9ubWVudCgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgcHJvY2VzcyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xyXG59XHJcbi8vIFRPRE8oY2xlYW51cCk6IFVzZSBjbGFzcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBwYXNzaW5nIGBpc0NhbmNlbGxlZGAgZXZlcnl3aGVyZS5cclxuZnVuY3Rpb24gbWFrZUNhbmNlbFRva2VuKCkge1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHsgY2FuY2VsOiAoKSA9PiAoY2FuY2VsbGVkID0gdHJ1ZSksIGlzQ2FuY2VsbGVkOiAoKSA9PiBjYW5jZWxsZWQgfTtcclxufVxyXG4vLyBUT0RPKGNsZWFudXApOiByZXBsYWNlIHdpdGggU0RLJ3MgYmFja29mZiBpbXBsZW1lbnRhdGlvblxyXG5jb25zdCBNSU5fUkVUUllfREVMQVkgPSAxMDAwO1xyXG5jb25zdCBSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbmNvbnN0IE1BWF9SRVRSWV9ERUxBWSA9IDMwMDAwO1xyXG5mdW5jdGlvbiB3aXRoQmFja29mZlJldHJpZXMoZiwgcmV0cnlDb3VudCwgc2hvdWxkUmV0cnkgPSAoKSA9PiB0cnVlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBuZXh0V2FpdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGlmIChpID49IHJldHJ5Q291bnQgfHwgIXNob3VsZFJldHJ5KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeWllbGQgZGVsYXkobmV4dFdhaXRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0V2FpdFRpbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1JTl9SRVRSWV9ERUxBWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1BWF9SRVRSWV9ERUxBWSwgUkVUUllfQkFDS09GRl9GQUNUT1IgKiBuZXh0V2FpdFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVsYXkobXMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcclxufVxyXG5mdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgcHJvbWlzZSxcclxuICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSksIG1zKSlcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIoZXZlbnQpIHtcclxuICAgIHJldHVybiBmcm9tSGV4KGV2ZW50Lm51bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9nc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZnJvbUhleChldmVudC5ibG9ja051bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobWVzc2FnZSkgfHxcclxuICAgICAgICAobWVzc2FnZS5qc29ucnBjID09PSAnMi4wJyAmJiBtZXNzYWdlLmlkICE9PSB1bmRlZmluZWQpKTtcclxufVxyXG5mdW5jdGlvbiBpc1N1YnNjcmlwdGlvbkV2ZW50KG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAhaXNSZXNwb25zZShtZXNzYWdlKTtcclxufVxyXG5mdW5jdGlvbiBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XHJcbiAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xyXG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgbmV3IGV2ZW50IHRvIGFuIGFycmF5IG9mIGV2ZW50cywgZXZpY3RpbmcgYW55IGV2ZW50cyB3aGljaCBhcmUgc28gb2xkXHJcbiAqIHRoYXQgdGhleSB3aWxsIG5vIGxvbmdlciBmZWFzaWJseSBiZSBwYXJ0IG9mIGEgcmVvcmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBnZXRCbG9ja051bWJlcihldmVudCk7XHJcbiAgICAvLyBGaW5kIGZpcnN0IGluZGV4IG9mIGFuIGV2ZW50IHJlY2VudCBlbm91Z2ggdG8gcmV0YWluLCB0aGVuIGRyb3AgZXZlcnl0aGluZ1xyXG4gICAgLy8gYXQgYSBsb3dlciBpbmRleC5cclxuICAgIGNvbnN0IGZpcnN0R29vZEluZGV4ID0gcGFzdEV2ZW50cy5maW5kSW5kZXgoZSA9PiBnZXRCbG9ja051bWJlcihlKSA+IGN1cnJlbnRCbG9ja051bWJlciAtIFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UKTtcclxuICAgIGlmIChmaXJzdEdvb2RJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBwYXN0RXZlbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXN0RXZlbnRzLnNwbGljZSgwLCBmaXJzdEdvb2RJbmRleCk7XHJcbiAgICB9XHJcbiAgICBwYXN0RXZlbnRzLnB1c2goZXZlbnQpO1xyXG59XG5cbmV4cG9ydCB7IEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItM2Q0OGU2YzAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-3d48e6c0.js\n"));

/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXM1LWV4dC9nbG9iYWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9lczUtZXh0L2dsb2JhbC5qcz9mYTZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuYWl2ZUZhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuXHRpZiAodHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgJiYgc2VsZikgcmV0dXJuIHNlbGY7XG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdykgcmV0dXJuIHdpbmRvdztcblx0dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMpIHJldHVybiB0aGlzO1xuXG5cdC8vIFVuZXhwZWN0ZWQgc3RyaWN0IG1vZGUgKG1heSBoYXBwZW4gaWYgZS5nLiBidW5kbGVkIGludG8gRVNNIG1vZHVsZSlcblxuXHQvLyBGYWxsYmFjayB0byBzdGFuZGFyZCBnbG9iYWxUaGlzIGlmIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiYgZ2xvYmFsVGhpcykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cblx0Ly8gVGhhbmtzIEBtYXRoaWFzYnluZW5zIC0+IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG5cdC8vIEluIGFsbCBFUzUrIGVuZ2luZXMgZ2xvYmFsIG9iamVjdCBpbmhlcml0cyBmcm9tIE9iamVjdC5wcm90b3R5cGVcblx0Ly8gKGlmIHlvdSBhcHByb2FjaGVkIG9uZSB0aGF0IGRvZXNuJ3QgcGxlYXNlIHJlcG9ydClcblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX2dsb2JhbF9fXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFVuZm9ydHVuYXRlIGNhc2Ugb2YgdXBkYXRlcyB0byBPYmplY3QucHJvdG90eXBlIGJlaW5nIHJlc3RyaWN0ZWRcblx0XHQvLyB2aWEgcHJldmVudEV4dGVuc2lvbnMsIHNlYWwgb3IgZnJlZXplXG5cdFx0cmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0fVxuXHR0cnkge1xuXHRcdC8vIFNhZmFyaSBjYXNlICh3aW5kb3cuX19nbG9iYWxfXyB3b3JrcywgYnV0IF9fZ2xvYmFsX18gZG9lcyBub3QpXG5cdFx0aWYgKCFfX2dsb2JhbF9fKSByZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHRcdHJldHVybiBfX2dsb2JhbF9fO1xuXHR9IGZpbmFsbHkge1xuXHRcdGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG5cdH1cbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/es5-ext/global.js\n"));

/***/ }),

/***/ "./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports[\"default\"] = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx3QkFBd0I7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsNkJBQTZCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtDQUFrQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzP2IzMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy53c0NvbnN0cnVjdG9yID0gV2ViU29ja2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IG5vdCBwcmVzZW50IGluIGdsb2JhbCBzY29wZSBhbmQgbm8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIndzQ29uc3RydWN0b3Igb3B0aW9uIHdhcyBwcm92aWRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuTmV3V2ViU29ja2V0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJpbmFyeVR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCB8fCBcImJsb2JcIjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoYmluYXJ5VHlwZSkge1xuICAgICAgICAgICAgdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJidWZmZXJlZEFtb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN1bSA9IHRoaXMud3MgPyB0aGlzLndzLmJ1ZmZlcmVkQW1vdW50IDogMDtcbiAgICAgICAgICAgIHZhciBoYXNVbmtub3duQW1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBieXRlTGVuZ3RoID0gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc1Vua25vd25BbW91bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc1Vua25vd25BbW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnTG9nKFwiU29tZSBidWZmZXJlZCBkYXRhIGhhZCB1bmtub3duIGxlbmd0aC4gYnVmZmVyZWRBbW91bnQoKVwiICtcbiAgICAgICAgICAgICAgICAgICAgXCIgcmV0dXJuIHZhbHVlIG1heSBiZSBiZWxvdyB0aGUgY29ycmVjdCBhbW91bnQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLmV4dGVuc2lvbnMgOiB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInByb3RvY29sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MucHJvdG9jb2wgOiB0aGlzLmxhc3RLbm93blByb3RvY29sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Nsb3NlZCA/IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQgOiBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KGNvZGUsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgaXMgYWxyZWFkeSBpbiBDTE9TSU5HIG9yIENMT1NFRCBzdGF0ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IHRoaXMuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgcmVjb25uZWN0KCkgb24gc29ja2V0IHdoaWNoIGlzIHBlcm1hbmVudGx5IGNsb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KDEwMDAsIFwiQ2xpZW50IHJlcXVlc3RlZCByZWNvbm5lY3QuXCIpO1xuICAgICAgICB0aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5saXN0ZW5lcnNbdHlwZV0uZmlsdGVyKGZ1bmN0aW9uIChsKSB7IHJldHVybiBsICE9PSBsaXN0ZW5lcjsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUub3Blbk5ld1dlYlNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIGNvbm5lY3RUaW1lb3V0ID0gX2EuY29ubmVjdFRpbWVvdXQsIHdzQ29uc3RydWN0b3IgPSBfYS53c0NvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiT3BlbmluZyBuZXcgV2ViU29ja2V0IHRvIFwiICsgdGhpcy51cmwgKyBcIi5cIik7XG4gICAgICAgIHZhciB3cyA9IG5ldyB3c0NvbnN0cnVjdG9yKHRoaXMudXJsLCB0aGlzLnByb3RvY29scyk7XG4gICAgICAgIHdzLm9uY2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUNsb3NlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRXJyb3IoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1lc3NhZ2UoZXZlbnQpOyB9O1xuICAgICAgICB3cy5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU9wZW4oZXZlbnQpOyB9O1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgcnVubmluZywgd2Ugc3RpbGwgaGF2ZW4ndCBvcGVuZWQgdGhlIHdlYnNvY2tldC5cbiAgICAgICAgICAgIC8vIEtpbGwgaXQgc28gd2UgY2FuIHRyeSBhZ2Fpbi5cbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZUNsb3NlKHVuZGVmaW5lZCk7XG4gICAgICAgIH0sIGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgdGhpcy53cyA9IHdzO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVPcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy53cyB8fCB0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbENsZWFyUmVzZXRUaW1lID0gdGhpcy5vcHRpb25zLmFsbENsZWFyUmVzZXRUaW1lO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IG9wZW5lZC5cIik7XG4gICAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gdGhpcy53cy5iaW5hcnlUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5oYXNCZWVuT3BlbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJyZW9wZW5cIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwib3BlblwiLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLmhhc0JlZW5PcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5zZW5kKG1lc3NhZ2UpOyB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBfdGhpcy5uZXh0UmV0cnlUaW1lID0gMDtcbiAgICAgICAgICAgIF90aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgICAgIHZhciBvcGVuVGltZSA9IChhbGxDbGVhclJlc2V0VGltZSAvIDEwMDApIHwgMDtcbiAgICAgICAgICAgIF90aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHJlbWFpbmVkIG9wZW4gZm9yIFwiICsgb3BlblRpbWUgKyBcIiBzZWNvbmRzLiBSZXNldHRpbmdcIiArXG4gICAgICAgICAgICAgICAgXCIgcmV0cnkgdGltZSBhbmQgY291bnQuXCIpO1xuICAgICAgICB9LCBhbGxDbGVhclJlc2V0VGltZSk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJtZXNzYWdlXCIsIGV2ZW50KTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlQ2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1heFJlY29ubmVjdEF0dGVtcHRzID0gX2EubWF4UmVjb25uZWN0QXR0ZW1wdHMsIHNob3VsZFJlY29ubmVjdCA9IF9hLnNob3VsZFJlY29ubmVjdDtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucyA9IHRoaXMud3MuZXh0ZW5zaW9ucztcbiAgICAgICAgICAgIHRoaXMubGFzdEtub3duUHJvdG9jb2wgPSB0aGlzLndzLnByb3RvY29sO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gIWV2ZW50IHx8IHNob3VsZFJlY29ubmVjdChldmVudCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lsbFJlY29ubmVjdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0LCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxSZWNvbm5lY3QudGhlbihmdW5jdGlvbiAod2lsbFJlY29ubmVjdFJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlV2lsbFJlY29ubmVjdCh3aWxsUmVjb25uZWN0UmVzb2x2ZWQsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVFcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnRPZlR5cGUoXCJlcnJvclwiLCBldmVudCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgZW5jb3VudGVyZWQgYW4gZXJyb3IuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVXaWxsUmVjb25uZWN0ID0gZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBkZW5pYWxSZWFzb24pIHtcbiAgICAgICAgaWYgKHdpbGxSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVlc3RhYmxpc2hDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIGRlbmlhbFJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUucmVlc3RhYmxpc2hDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMsIG1pblJlY29ubmVjdERlbGF5ID0gX2EubWluUmVjb25uZWN0RGVsYXksIG1heFJlY29ubmVjdERlbGF5ID0gX2EubWF4UmVjb25uZWN0RGVsYXksIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IgPSBfYS5yZWNvbm5lY3RCYWNrb2ZmRmFjdG9yO1xuICAgICAgICB0aGlzLnJlY29ubmVjdENvdW50Kys7XG4gICAgICAgIHZhciByZXRyeVRpbWUgPSB0aGlzLm5leHRSZXRyeVRpbWU7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IE1hdGgubWF4KG1pblJlY29ubmVjdERlbGF5LCBNYXRoLm1pbih0aGlzLm5leHRSZXRyeVRpbWUgKiByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yLCBtYXhSZWNvbm5lY3REZWxheSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTsgfSwgcmV0cnlUaW1lKTtcbiAgICAgICAgdmFyIHJldHJ5VGltZVNlY29uZHMgPSAocmV0cnlUaW1lIC8gMTAwMCkgfCAwO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IHdhcyBjbG9zZWQuIFJlLW9wZW5pbmcgaW4gXCIgKyByZXRyeVRpbWVTZWNvbmRzICsgXCIgc2Vjb25kcy5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnN0b3BSZWNvbm5lY3RpbmcgPSBmdW5jdGlvbiAoZXZlbnQsIGRlYnVnUmVhc29uKSB7XG4gICAgICAgIHRoaXMuZGVidWdMb2coZGVidWdSZWFzb24pO1xuICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNodXRkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhckFsbFRpbWVvdXRzKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmRpc3Bvc2VTb2NrZXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGlzcG9zZVNvY2tldCA9IGZ1bmN0aW9uIChjbG9zZUNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAoIXRoaXMud3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2Ugbm9vcCBoYW5kbGVycyBpbnN0ZWFkIG9mIG51bGwgYmVjYXVzZSBzb21lIFdlYlNvY2tldFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMsIHN1Y2ggYXMgdGhlIG9uZSBmcm9tIGlzb21vcnBoaWMtd3MsIHJhaXNlIGEgc3Rpbmsgb25cbiAgICAgICAgLy8gdW5oYW5kbGVkIGV2ZW50cy5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBub29wO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IG5vb3A7XG4gICAgICAgIHRoaXMud3MuY2xvc2UoY2xvc2VDb2RlLCByZWFzb24pO1xuICAgICAgICB0aGlzLndzID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbFRpbWVvdXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckNvbm5lY3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsZWFyQWxsQ2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5hbGxDbGVhclRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hbGxDbGVhclRpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnRPZlR5cGUgPSBmdW5jdGlvbiAodHlwZSwgZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jbG9zZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25tZXNzYWdlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ub3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRvd25cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbmRvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmRvd24oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZW9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbnJlb3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ucmVvcGVuKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdXG4gICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIF90aGlzLmNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgZXZlbnQpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWV2ZW50IHx8ICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jYWxsTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kZWJ1Z0xvZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5nZXRUb29NYW55RmFpbGVkUmVjb25uZWN0c01lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IHRoaXMub3B0aW9ucy5tYXhSZWNvbm5lY3RBdHRlbXB0cztcbiAgICAgICAgcmV0dXJuIFwiRmFpbGVkIHRvIHJlY29ubmVjdCBhZnRlciBcIiArIG1heFJlY29ubmVjdEF0dGVtcHRzICsgXCIgXCIgKyBwbHVyYWxpemUoXCJhdHRlbXB0XCIsIG1heFJlY29ubmVjdEF0dGVtcHRzKSArIFwiLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAgICAgYWxsQ2xlYXJSZXNldFRpbWU6IDUwMDAsXG4gICAgICAgIGNvbm5lY3RUaW1lb3V0OiA1MDAwLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIG1pblJlY29ubmVjdERlbGF5OiAxMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3REZWxheTogMzAwMDAsXG4gICAgICAgIG1heFJlY29ubmVjdEF0dGVtcHRzOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHJlY29ubmVjdEJhY2tvZmZGYWN0b3I6IDEuNSxcbiAgICAgICAgc2hvdWxkUmVjb25uZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB3c0NvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORyA9IDA7XG4gICAgU3R1cmR5V2ViU29ja2V0Lk9QRU4gPSAxO1xuICAgIFN0dXJkeVdlYlNvY2tldC5DTE9TSU5HID0gMjtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEID0gMztcbiAgICByZXR1cm4gU3R1cmR5V2ViU29ja2V0O1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0dXJkeVdlYlNvY2tldDtcbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICByZXN1bHRba2V5XSA9XG4gICAgICAgICAgICB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTdHVyZHlXZWJTb2NrZXQuREVGQVVMVF9PUFRJT05TW2tleV1cbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBOb3RoaW5nLlxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/sturdy-websocket/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = __webpack_require__(/*! es5-ext/global */ \"./node_modules/es5-ext/global.js\");\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFnQjtBQUN4QyxHQUFHO0FBQ0gsR0FBRztBQUNILHVEQUF1RDtBQUN2RCxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBEQUFXOzs7QUFHM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvYnJvd3Nlci5qcz9lY2NmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZ2xvYmFsVGhpcztcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHtcblx0X2dsb2JhbFRoaXMgPSBnbG9iYWxUaGlzO1xufSBlbHNlIHtcblx0dHJ5IHtcblx0XHRfZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJ2VzNS1leHQvZ2xvYmFsJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKCFfZ2xvYmFsVGhpcyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBfZ2xvYmFsVGhpcyA9IHdpbmRvdzsgfVxuXHRcdGlmICghX2dsb2JhbFRoaXMpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGdsb2JhbCB0aGlzJyk7IH1cblx0fVxufVxuXG52YXIgTmF0aXZlV2ViU29ja2V0ID0gX2dsb2JhbFRoaXMuV2ViU29ja2V0IHx8IF9nbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbnZhciB3ZWJzb2NrZXRfdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5cbi8qKlxuICogRXhwb3NlIGEgVzNDIFdlYlNvY2tldCBjbGFzcyB3aXRoIGp1c3Qgb25lIG9yIHR3byBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmksIHByb3RvY29scykge1xuXHR2YXIgbmF0aXZlX2luc3RhbmNlO1xuXG5cdGlmIChwcm90b2NvbHMpIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogJ25hdGl2ZV9pbnN0YW5jZScgaXMgYW4gaW5zdGFuY2Ugb2YgbmF0aXZlV2ViU29ja2V0ICh0aGUgYnJvd3NlcidzIFdlYlNvY2tldFxuXHQgKiBjbGFzcykuIFNpbmNlIGl0IGlzIGFuIE9iamVjdCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzIHdoZW4gY3JlYXRpbmcgYW5cblx0ICogaW5zdGFuY2Ugb2YgVzNDV2ViU29ja2V0IHZpYSAnbmV3IFczQ1dlYlNvY2tldCgpJy5cblx0ICpcblx0ICogRUNNQVNjcmlwdCA1OiBodHRwOi8vYmNsYXJ5LmNvbS8yMDA0LzExLzA3LyNhLTEzLjIuMlxuXHQgKi9cblx0cmV0dXJuIG5hdGl2ZV9pbnN0YW5jZTtcbn1cbmlmIChOYXRpdmVXZWJTb2NrZXQpIHtcblx0WydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTmF0aXZlV2ViU29ja2V0W3Byb3BdOyB9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndzNjd2Vic29ja2V0JyA6IE5hdGl2ZVdlYlNvY2tldCA/IFczQ1dlYlNvY2tldCA6IG51bGwsXG4gICAgJ3ZlcnNpb24nICAgICAgOiB3ZWJzb2NrZXRfdmVyc2lvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/websocket/lib/browser.js\n"));

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDRHQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzPzE0MjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/websocket/lib/version.js\n"));

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = JSON.parse('{"name":"websocket","description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"author":"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)","contributors":["Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],"version":"1.0.34","repository":{"type":"git","url":"https://github.com/theturtle32/WebSocket-Node.git"},"homepage":"https://github.com/theturtle32/WebSocket-Node","engines":{"node":">=4.0.0"},"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint-stylish":"^2.2.1","jshint":"^2.0.0","tape":"^4.9.1"},"config":{"verbose":false},"scripts":{"test":"tape test/unit/*.js","gulp":"gulp"},"main":"index","directories":{"lib":"./lib"},"browser":"lib/browser.js","license":"Apache-2.0"}');

/***/ })

}]);