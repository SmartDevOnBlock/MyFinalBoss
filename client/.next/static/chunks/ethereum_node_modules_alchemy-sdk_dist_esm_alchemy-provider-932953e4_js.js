"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["ethereum_node_modules_alchemy-sdk_dist_esm_alchemy-provider-932953e4_js"],{

/***/ "../ethereum/node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js":
/*!**********************************************************************************!*\
  !*** ../ethereum/node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AlchemyProvider\": function() { return /* binding */ AlchemyProvider; }\n/* harmony export */ });\n/* harmony import */ var _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index-32cab09d.js */ \"../ethereum/node_modules/alchemy-sdk/dist/esm/index-32cab09d.js\");\n/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ \"../ethereum/node_modules/@ethersproject/networks/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/providers */ \"../ethereum/node_modules/@ethersproject/providers/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/web */ \"../ethereum/node_modules/@ethersproject/web/lib.esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"../ethereum/node_modules/axios/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n\n\n\n\n\n\n\n\n/** Maximum size of a batch on the rpc provider. */\r\nconst DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;\r\n/** Timeout interval before the pending batch is sent. */\r\nconst DEFAULT_REQUEST_BATCH_DELAY_MS = 10;\r\n/**\r\n * Internal class to enqueue requests and automatically send/process batches.\r\n *\r\n * The underlying batching mechanism is loosely based on ethers.js's\r\n * `JsonRpcBatchProvider`.\r\n *\r\n * @internal\r\n */\r\nclass RequestBatcher {\r\n    constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {\r\n        this.sendBatchFn = sendBatchFn;\r\n        this.maxBatchSize = maxBatchSize;\r\n        /**\r\n         * Array of enqueued requests along with the constructed promise handlers for\r\n         * each request.\r\n         */\r\n        this.pendingBatch = [];\r\n    }\r\n    /**\r\n     * Enqueues the provided request. The batch is immediately sent if the maximum\r\n     * batch size is reached. Otherwise, the request is enqueued onto a batch that\r\n     * is sent after 10ms.\r\n     *\r\n     * Returns a promise that resolves with the result of the request.\r\n     */\r\n    enqueueRequest(request) {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            const inflightRequest = {\r\n                request,\r\n                resolve: undefined,\r\n                reject: undefined\r\n            };\r\n            const promise = new Promise((resolve, reject) => {\r\n                inflightRequest.resolve = resolve;\r\n                inflightRequest.reject = reject;\r\n            });\r\n            this.pendingBatch.push(inflightRequest);\r\n            if (this.pendingBatch.length === this.maxBatchSize) {\r\n                // Send batch immediately if we are at the maximum batch size.\r\n                void this.sendBatchRequest();\r\n            }\r\n            else if (!this.pendingBatchTimer) {\r\n                // Schedule batch for next event loop + short duration\r\n                this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);\r\n            }\r\n            return promise;\r\n        });\r\n    }\r\n    /**\r\n     * Sends the currently queued batches and resets the batch and timer. Processes\r\n     * the batched response results back to the original promises.\r\n     */\r\n    sendBatchRequest() {\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            // Get the current batch and clear it, so new requests\r\n            // go into the next batch\r\n            const batch = this.pendingBatch;\r\n            this.pendingBatch = [];\r\n            if (this.pendingBatchTimer) {\r\n                clearTimeout(this.pendingBatchTimer);\r\n                this.pendingBatchTimer = undefined;\r\n            }\r\n            // Get the request as an array of requests\r\n            const request = batch.map(inflight => inflight.request);\r\n            return this.sendBatchFn(request).then(result => {\r\n                // For each result, feed it to the correct Promise, depending\r\n                // on whether it was a success or error\r\n                batch.forEach((inflightRequest, index) => {\r\n                    const payload = result[index];\r\n                    if (payload.error) {\r\n                        const error = new Error(payload.error.message);\r\n                        error.code = payload.error.code;\r\n                        error.data = payload.error.data;\r\n                        inflightRequest.reject(error);\r\n                    }\r\n                    else {\r\n                        inflightRequest.resolve(payload.result);\r\n                    }\r\n                });\r\n            }, error => {\r\n                batch.forEach(inflightRequest => {\r\n                    inflightRequest.reject(error);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\n\n/**\r\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {\r\n    /** @internal */\r\n    constructor(config) {\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'http');\r\n        // If a hardcoded url was specified in the config, use that instead of the\r\n        // provided apiKey or network.\r\n        if (config.url !== undefined) {\r\n            connection.url = config.url;\r\n        }\r\n        connection.throttleLimit = config.maxRetries;\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.E[alchemyNetwork];\r\n        super(connection, ethersNetwork);\r\n        this.apiKey = config.apiKey;\r\n        this.maxRetries = config.maxRetries;\r\n        this.batchRequests = config.batchRequests;\r\n        // TODO: support individual headers when calling batch\r\n        const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { 'Alchemy-Ethers-Sdk-Method': 'batchSend' }) });\r\n        const sendBatchFn = (requests) => {\r\n            return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(batcherConnection, JSON.stringify(requests));\r\n        };\r\n        this.batcher = new RequestBatcher(sendBatchFn);\r\n    }\r\n    /**\r\n     * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\r\n     * ethers.js. Returns the API key for an Alchemy provider.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getApiKey(apiKey) {\r\n        if (apiKey == null) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n        }\r\n        if (apiKey && typeof apiKey !== 'string') {\r\n            throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);\r\n        }\r\n        return apiKey;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.C) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.C[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);\r\n    }\r\n    /**\r\n     * Converts the `Networkish` input to the network enum used by Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyNetwork(network) {\r\n        if (network === undefined) {\r\n            return _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.a;\r\n        }\r\n        if (typeof network === 'number') {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be a string.`);\r\n        }\r\n        // Guaranteed that `typeof network === 'string`.\r\n        const isValidNetwork = Object.values(_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.N).includes(network);\r\n        if (!isValidNetwork) {\r\n            throw new Error(`Invalid network '${network}' provided. Network must be one of: ` +\r\n                `${Object.values(_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.N).join(', ')}.`);\r\n        }\r\n        return network;\r\n    }\r\n    /**\r\n     * Returns a {@link ConnectionInfo} object compatible with ethers that contains\r\n     * the correct URLs for Alchemy.\r\n     *\r\n     * @internal\r\n     */\r\n    static getAlchemyConnectionInfo(network, apiKey, type) {\r\n        const url = type === 'http'\r\n            ? (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.g)(network, apiKey)\r\n            : (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.b)(network, apiKey);\r\n        return {\r\n            headers: _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.I\r\n                ? {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.V\r\n                }\r\n                : {\r\n                    'Alchemy-Ethers-Sdk-Version': _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.V,\r\n                    'Accept-Encoding': 'gzip'\r\n                },\r\n            allowGzip: true,\r\n            url\r\n        };\r\n    }\r\n    /**\r\n     * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\r\n     * method is called when calling methods on the parent class `BaseProvider`.\r\n     *\r\n     * @override\r\n     */\r\n    detectNetwork() {\r\n        const _super = Object.create(null, {\r\n            detectNetwork: { get: () => super.detectNetwork }\r\n        });\r\n        return (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__._)(this, void 0, void 0, function* () {\r\n            let network = this.network;\r\n            if (network == null) {\r\n                network = yield _super.detectNetwork.call(this);\r\n                if (!network) {\r\n                    throw new Error('No network detected');\r\n                }\r\n            }\r\n            return network;\r\n        });\r\n    }\r\n    _startPending() {\r\n        (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.l)('WARNING: Alchemy Provider does not support pending filters');\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === _index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.D;\r\n    }\r\n    /**\r\n     * Overrides the base {@link JsonRpcProvider.send} method to implement custom\r\n     * logic for sending requests to Alchemy.\r\n     *\r\n     * @param method The method name to use for the request.\r\n     * @param params The parameters to use for the request.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Add headers for `perform()` override.\r\n    send(method, params) {\r\n        return this._send(method, params, 'send');\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `JsonRpcProvider.send()`.\r\n     *\r\n     * This method is copied over directly in order to implement custom headers\r\n     *\r\n     * @internal\r\n     */\r\n    _send(method, params, methodName, forceBatch = false) {\r\n        const request = {\r\n            method,\r\n            params,\r\n            id: this._nextId++,\r\n            jsonrpc: '2.0'\r\n        };\r\n        // START MODIFIED CODE\r\n        const connection = Object.assign({}, this.connection);\r\n        connection.headers['Alchemy-Ethers-Sdk-Method'] = methodName;\r\n        if (this.batchRequests || forceBatch) {\r\n            return this.batcher.enqueueRequest(request);\r\n        }\r\n        // END MODIFIED CODE\r\n        this.emit('debug', {\r\n            action: 'request',\r\n            request: (0,_index_32cab09d_js__WEBPACK_IMPORTED_MODULE_1__.d)(request),\r\n            provider: this\r\n        });\r\n        // We can expand this in the future to any call, but for now these\r\n        // are the biggest wins and do not require any serializing parameters.\r\n        const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\r\n        if (cache && this._cache[method]) {\r\n            return this._cache[method];\r\n        }\r\n        const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                request,\r\n                response: result,\r\n                provider: this\r\n            });\r\n            return result;\r\n        }, error => {\r\n            this.emit('debug', {\r\n                action: 'response',\r\n                error,\r\n                request,\r\n                provider: this\r\n            });\r\n            throw error;\r\n        });\r\n        // Cache the fetch, but clear it on the next event loop\r\n        if (cache) {\r\n            this._cache[method] = result;\r\n            setTimeout(() => {\r\n                // @ts-ignore - This is done by ethers.\r\n                this._cache[method] = null;\r\n            }, 0);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * DO NOT MODIFY.\r\n *\r\n * Original code copied over from ether.js's\r\n * `@ethersproject/web/src.ts/index.ts`. Used to support\r\n * {@link AlchemyProvider._send}, which is also copied over.\r\n */\r\nfunction getResult(payload) {\r\n    if (payload.error) {\r\n        const error = new Error(payload.error.message);\r\n        error.code = payload.error.code;\r\n        error.data = payload.error.data;\r\n        throw error;\r\n    }\r\n    return payload.result;\r\n}\n\n\n//# sourceMappingURL=alchemy-provider-932953e4.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZXRoZXJldW0vbm9kZV9tb2R1bGVzL2FsY2hlbXktc2RrL2Rpc3QvZXNtL2FsY2hlbXktcHJvdmlkZXItOTMyOTUzZTQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwUTtBQUNyTjtBQUNNO0FBQ1o7QUFDMUI7QUFDYTtBQUNuQjtBQUMyQjtBQUNYO0FBQ0c7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWUsVUFBVSxtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCLHVDQUF1Qyw4QkFBOEIsMENBQTBDLEdBQUc7QUFDeE07QUFDQSxtQkFBbUIsNkRBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlEQUF1QjtBQUMxQztBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaURBQWM7QUFDcEUsbUJBQW1CLGlEQUFjO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLG1FQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaURBQWU7QUFDbEM7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkMsaURBQU87QUFDcEQ7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RCxtQkFBbUIsY0FBYyxpREFBTyxhQUFhO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFEQUFpQjtBQUMvQixjQUFjLHFEQUFlO0FBQzdCO0FBQ0EscUJBQXFCLGlEQUFVO0FBQy9CO0FBQ0Esa0RBQWtELGlEQUFPO0FBQ3pEO0FBQ0E7QUFDQSxrREFBa0QsaURBQU87QUFDekQ7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLFNBQVM7QUFDVCxlQUFlLHFEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUF1QjtBQUN0RDtBQUNBO0FBQ0EsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBUTtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL2V0aGVyZXVtL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXByb3ZpZGVyLTkzMjk1M2U0LmpzP2E1OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfX2F3YWl0ZXIsIEQgYXMgREVGQVVMVF9BTENIRU1ZX0FQSV9LRVksIEMgYXMgQ3VzdG9tTmV0d29ya3MsIGEgYXMgREVGQVVMVF9ORVRXT1JLLCBOIGFzIE5ldHdvcmssIEkgYXMgSVNfQlJPV1NFUiwgViBhcyBWRVJTSU9OLCBsIGFzIGxvZ1dhcm4sIGQgYXMgZGVlcENvcHksIEUgYXMgRXRoZXJzTmV0d29yaywgZyBhcyBnZXRBbGNoZW15SHR0cFVybCwgYiBhcyBnZXRBbGNoZW15V3NVcmwgfSBmcm9tICcuL2luZGV4LTMyY2FiMDlkLmpzJztcbmltcG9ydCB7IGdldE5ldHdvcmsgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9uZXR3b3Jrcyc7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9wcm92aWRlcnMnO1xuaW1wb3J0IHsgZmV0Y2hKc29uIH0gZnJvbSAnQGV0aGVyc3Byb2plY3Qvd2ViJztcbmltcG9ydCAnLi9hcGkvdXRpbHMnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInO1xuaW1wb3J0ICdheGlvcyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyJztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3Qvd2FsbGV0JztcbmltcG9ydCAnQGV0aGVyc3Byb2plY3QvY29udHJhY3RzJztcblxuLyoqIE1heGltdW0gc2l6ZSBvZiBhIGJhdGNoIG9uIHRoZSBycGMgcHJvdmlkZXIuICovXHJcbmNvbnN0IERFRkFVTFRfTUFYX1JFUVVFU1RfQkFUQ0hfU0laRSA9IDEwMDtcclxuLyoqIFRpbWVvdXQgaW50ZXJ2YWwgYmVmb3JlIHRoZSBwZW5kaW5nIGJhdGNoIGlzIHNlbnQuICovXHJcbmNvbnN0IERFRkFVTFRfUkVRVUVTVF9CQVRDSF9ERUxBWV9NUyA9IDEwO1xyXG4vKipcclxuICogSW50ZXJuYWwgY2xhc3MgdG8gZW5xdWV1ZSByZXF1ZXN0cyBhbmQgYXV0b21hdGljYWxseSBzZW5kL3Byb2Nlc3MgYmF0Y2hlcy5cclxuICpcclxuICogVGhlIHVuZGVybHlpbmcgYmF0Y2hpbmcgbWVjaGFuaXNtIGlzIGxvb3NlbHkgYmFzZWQgb24gZXRoZXJzLmpzJ3NcclxuICogYEpzb25ScGNCYXRjaFByb3ZpZGVyYC5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZXF1ZXN0QmF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzZW5kQmF0Y2hGbiwgbWF4QmF0Y2hTaXplID0gREVGQVVMVF9NQVhfUkVRVUVTVF9CQVRDSF9TSVpFKSB7XHJcbiAgICAgICAgdGhpcy5zZW5kQmF0Y2hGbiA9IHNlbmRCYXRjaEZuO1xyXG4gICAgICAgIHRoaXMubWF4QmF0Y2hTaXplID0gbWF4QmF0Y2hTaXplO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFycmF5IG9mIGVucXVldWVkIHJlcXVlc3RzIGFsb25nIHdpdGggdGhlIGNvbnN0cnVjdGVkIHByb21pc2UgaGFuZGxlcnMgZm9yXHJcbiAgICAgICAgICogZWFjaCByZXF1ZXN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0JhdGNoID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIHRoZSBwcm92aWRlZCByZXF1ZXN0LiBUaGUgYmF0Y2ggaXMgaW1tZWRpYXRlbHkgc2VudCBpZiB0aGUgbWF4aW11bVxyXG4gICAgICogYmF0Y2ggc2l6ZSBpcyByZWFjaGVkLiBPdGhlcndpc2UsIHRoZSByZXF1ZXN0IGlzIGVucXVldWVkIG9udG8gYSBiYXRjaCB0aGF0XHJcbiAgICAgKiBpcyBzZW50IGFmdGVyIDEwbXMuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWVSZXF1ZXN0KHJlcXVlc3QpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpbmZsaWdodFJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgcmVqZWN0OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdCYXRjaC5sZW5ndGggPT09IHRoaXMubWF4QmF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGJhdGNoIGltbWVkaWF0ZWx5IGlmIHdlIGFyZSBhdCB0aGUgbWF4aW11bSBiYXRjaCBzaXplLlxyXG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnNlbmRCYXRjaFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5wZW5kaW5nQmF0Y2hUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmRCYXRjaFJlcXVlc3QoKSwgREVGQVVMVF9SRVFVRVNUX0JBVENIX0RFTEFZX01TKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgdGhlIGN1cnJlbnRseSBxdWV1ZWQgYmF0Y2hlcyBhbmQgcmVzZXRzIHRoZSBiYXRjaCBhbmQgdGltZXIuIFByb2Nlc3Nlc1xyXG4gICAgICogdGhlIGJhdGNoZWQgcmVzcG9uc2UgcmVzdWx0cyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBwcm9taXNlcy5cclxuICAgICAqL1xyXG4gICAgc2VuZEJhdGNoUmVxdWVzdCgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYmF0Y2ggYW5kIGNsZWFyIGl0LCBzbyBuZXcgcmVxdWVzdHNcclxuICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxyXG4gICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMucGVuZGluZ0JhdGNoO1xyXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdCYXRjaCA9IFtdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQmF0Y2hUaW1lcikge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucGVuZGluZ0JhdGNoVGltZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQmF0Y2hUaW1lciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlcXVlc3QgYXMgYW4gYXJyYXkgb2YgcmVxdWVzdHNcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGJhdGNoLm1hcChpbmZsaWdodCA9PiBpbmZsaWdodC5yZXF1ZXN0KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZEJhdGNoRm4ocmVxdWVzdCkudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcmVzdWx0LCBmZWVkIGl0IHRvIHRoZSBjb3JyZWN0IFByb21pc2UsIGRlcGVuZGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXHJcbiAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHJlc3VsdFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHBheWxvYWQuZXJyb3IuY29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVzb2x2ZShwYXlsb2FkLnJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goaW5mbGlnaHRSZXF1ZXN0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogU0RLJ3MgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycy5qcydzICdBbGNoZW15UHJvdmlkZXInLlxyXG4gKlxyXG4gKiBEbyBub3QgY2FsbCB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiBJbnN0ZWFkLCBpbnN0YW50aWF0ZSBhbiBpbnN0YW5jZSBvZlxyXG4gKiB7QGxpbmsgQWxjaGVteX0gYW5kIGNhbGwge0BsaW5rIEFsY2hlbXkuY29uZmlnLmdldFByb3ZpZGVyKCl9LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBBUEkgS2V5IHRvIGEgc3RyaW5nLlxyXG4gICAgICAgIGNvbnN0IGFwaUtleSA9IEFsY2hlbXlQcm92aWRlci5nZXRBcGlLZXkoY29uZmlnLmFwaUtleSk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgb3VyIG93biBjb25uZWN0aW9uIGluZm8gd2l0aCB0aGUgY29ycmVjdCBlbmRwb2ludCBVUkxzLlxyXG4gICAgICAgIGNvbnN0IGFsY2hlbXlOZXR3b3JrID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlOZXR3b3JrKGNvbmZpZy5uZXR3b3JrKTtcclxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gQWxjaGVteVByb3ZpZGVyLmdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhhbGNoZW15TmV0d29yaywgYXBpS2V5LCAnaHR0cCcpO1xyXG4gICAgICAgIC8vIElmIGEgaGFyZGNvZGVkIHVybCB3YXMgc3BlY2lmaWVkIGluIHRoZSBjb25maWcsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlXHJcbiAgICAgICAgLy8gcHJvdmlkZWQgYXBpS2V5IG9yIG5ldHdvcmsuXHJcbiAgICAgICAgaWYgKGNvbmZpZy51cmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25uZWN0aW9uLnVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbm5lY3Rpb24udGhyb3R0bGVMaW1pdCA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgQWxjaGVteSBuYW1lZCBuZXR3b3JrIGlucHV0IHRvIHRoZSBuZXR3b3JrIG5hbWVzIHVzZWQgYnlcclxuICAgICAgICAvLyBldGhlcnMuIFRoaXMgYWxsb3dzIHRoZSBwYXJlbnQgc3VwZXIgY29uc3RydWN0b3IgaW4gSnNvblJwY1Byb3ZpZGVyIHRvXHJcbiAgICAgICAgLy8gY29ycmVjdGx5IHNldCB0aGUgbmV0d29yay5cclxuICAgICAgICBjb25zdCBldGhlcnNOZXR3b3JrID0gRXRoZXJzTmV0d29ya1thbGNoZW15TmV0d29ya107XHJcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgZXRoZXJzTmV0d29yayk7XHJcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBjb25maWcuYXBpS2V5O1xyXG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IGNvbmZpZy5tYXhSZXRyaWVzO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hSZXF1ZXN0cyA9IGNvbmZpZy5iYXRjaFJlcXVlc3RzO1xyXG4gICAgICAgIC8vIFRPRE86IHN1cHBvcnQgaW5kaXZpZHVhbCBoZWFkZXJzIHdoZW4gY2FsbGluZyBiYXRjaFxyXG4gICAgICAgIGNvbnN0IGJhdGNoZXJDb25uZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb24pLCB7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uLmhlYWRlcnMpLCB7ICdBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJzogJ2JhdGNoU2VuZCcgfSkgfSk7XHJcbiAgICAgICAgY29uc3Qgc2VuZEJhdGNoRm4gPSAocmVxdWVzdHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGZldGNoSnNvbihiYXRjaGVyQ29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlciA9IG5ldyBSZXF1ZXN0QmF0Y2hlcihzZW5kQmF0Y2hGbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFVybEpzb25ScGNQcm92aWRlci5nZXRBcGlLZXlgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieVxyXG4gICAgICogZXRoZXJzLmpzLiBSZXR1cm5zIHRoZSBBUEkga2V5IGZvciBhbiBBbGNoZW15IHByb3ZpZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XHJcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwaUtleSAmJiB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYXBpS2V5ICcke2FwaUtleX0nIHByb3ZpZGVkLiBhcGlLZXkgbXVzdCBiZSBhIHN0cmluZy5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaUtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgQmFzZVByb3ZpZGVyLmdldE5ldHdvcmtgIG1ldGhvZCBhcyBpbXBsZW1lbnRlZCBieSBldGhlcnMuanMuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBvdmVycmlkZSBhbGxvd3MgdGhlIFNESyB0byBzZXQgdGhlIHByb3ZpZGVyJ3MgbmV0d29yayB0byB2YWx1ZXMgbm90XHJcbiAgICAgKiB5ZXQgc3VwcG9ydGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJyAmJiBuZXR3b3JrIGluIEN1c3RvbU5ldHdvcmtzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDdXN0b21OZXR3b3Jrc1tuZXR3b3JrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2FsbCB0aGUgc3RhbmRhcmQgZXRoZXJzLmpzIGdldE5ldHdvcmsgbWV0aG9kIGZvciBvdGhlciBuZXR3b3Jrcy5cclxuICAgICAgICByZXR1cm4gZ2V0TmV0d29yayhuZXR3b3JrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGBOZXR3b3JraXNoYCBpbnB1dCB0byB0aGUgbmV0d29yayBlbnVtIHVzZWQgYnkgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlOZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAobmV0d29yayA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX05FVFdPUks7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgbmV0d29yayA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5ldHdvcmsgJyR7bmV0d29ya30nIHByb3ZpZGVkLiBOZXR3b3JrIG11c3QgYmUgYSBzdHJpbmcuYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEd1YXJhbnRlZWQgdGhhdCBgdHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmdgLlxyXG4gICAgICAgIGNvbnN0IGlzVmFsaWROZXR3b3JrID0gT2JqZWN0LnZhbHVlcyhOZXR3b3JrKS5pbmNsdWRlcyhuZXR3b3JrKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBuZXR3b3JrICcke25ldHdvcmt9JyBwcm92aWRlZC4gTmV0d29yayBtdXN0IGJlIG9uZSBvZjogYCArXHJcbiAgICAgICAgICAgICAgICBgJHtPYmplY3QudmFsdWVzKE5ldHdvcmspLmpvaW4oJywgJyl9LmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHtAbGluayBDb25uZWN0aW9uSW5mb30gb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBldGhlcnMgdGhhdCBjb250YWluc1xyXG4gICAgICogdGhlIGNvcnJlY3QgVVJMcyBmb3IgQWxjaGVteS5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEFsY2hlbXlDb25uZWN0aW9uSW5mbyhuZXR3b3JrLCBhcGlLZXksIHR5cGUpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSB0eXBlID09PSAnaHR0cCdcclxuICAgICAgICAgICAgPyBnZXRBbGNoZW15SHR0cFVybChuZXR3b3JrLCBhcGlLZXkpXHJcbiAgICAgICAgICAgIDogZ2V0QWxjaGVteVdzVXJsKG5ldHdvcmssIGFwaUtleSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGVhZGVyczogSVNfQlJPV1NFUlxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogVkVSU0lPTlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0FsY2hlbXktRXRoZXJzLVNkay1WZXJzaW9uJzogVkVSU0lPTixcclxuICAgICAgICAgICAgICAgICAgICAnQWNjZXB0LUVuY29kaW5nJzogJ2d6aXAnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXHJcbiAgICAgICAgICAgIHVybFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgbWV0aG9kIGluIGV0aGVycy5qcydzIGBTdGF0aWNKc29uUnBjUHJvdmlkZXJgIGNsYXNzLiBUaGlzXHJcbiAgICAgKiBtZXRob2QgaXMgY2FsbGVkIHdoZW4gY2FsbGluZyBtZXRob2RzIG9uIHRoZSBwYXJlbnQgY2xhc3MgYEJhc2VQcm92aWRlcmAuXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRldGVjdE5ldHdvcmsoKSB7XHJcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XHJcbiAgICAgICAgICAgIGRldGVjdE5ldHdvcms6IHsgZ2V0OiAoKSA9PiBzdXBlci5kZXRlY3ROZXR3b3JrIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBsZXQgbmV0d29yayA9IHRoaXMubmV0d29yaztcclxuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIF9zdXBlci5kZXRlY3ROZXR3b3JrLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5ldHdvcmsgZGV0ZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9zdGFydFBlbmRpbmcoKSB7XHJcbiAgICAgICAgbG9nV2FybignV0FSTklORzogQWxjaGVteSBQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVycycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlcyB0aGUgYmFzZSB7QGxpbmsgSnNvblJwY1Byb3ZpZGVyLnNlbmR9IG1ldGhvZCB0byBpbXBsZW1lbnQgY3VzdG9tXHJcbiAgICAgKiBsb2dpYyBmb3Igc2VuZGluZyByZXF1ZXN0cyB0byBBbGNoZW15LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbWV0ZXJzIHRvIHVzZSBmb3IgdGhlIHJlcXVlc3QuXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogQWRkIGhlYWRlcnMgZm9yIGBwZXJmb3JtKClgIG92ZXJyaWRlLlxyXG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKG1ldGhvZCwgcGFyYW1zLCAnc2VuZCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBKc29uUnBjUHJvdmlkZXIuc2VuZCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgY3VzdG9tIGhlYWRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3NlbmQobWV0aG9kLCBwYXJhbXMsIG1ldGhvZE5hbWUsIGZvcmNlQmF0Y2ggPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcGFyYW1zLFxyXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dElkKyssXHJcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTVEFSVCBNT0RJRklFRCBDT0RFXHJcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbik7XHJcbiAgICAgICAgY29ubmVjdGlvbi5oZWFkZXJzWydBbGNoZW15LUV0aGVycy1TZGstTWV0aG9kJ10gPSBtZXRob2ROYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoUmVxdWVzdHMgfHwgZm9yY2VCYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXRjaGVyLmVucXVldWVSZXF1ZXN0KHJlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgIGFjdGlvbjogJ3JlcXVlc3QnLFxyXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcclxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoaXMgaW4gdGhlIGZ1dHVyZSB0byBhbnkgY2FsbCwgYnV0IGZvciBub3cgdGhlc2VcclxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSBbJ2V0aF9jaGFpbklkJywgJ2V0aF9ibG9ja051bWJlciddLmluZGV4T2YobWV0aG9kKSA+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBmZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVidWcnLCB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdyZXNwb25zZScsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWJ1ZycsIHtcclxuICAgICAgICAgICAgICAgIGFjdGlvbjogJ3Jlc3BvbnNlJyxcclxuICAgICAgICAgICAgICAgIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcclxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBDYWNoZSB0aGUgZmV0Y2gsIGJ1dCBjbGVhciBpdCBvbiB0aGUgbmV4dCBldmVudCBsb29wXHJcbiAgICAgICAgaWYgKGNhY2hlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgZG9uZSBieSBldGhlcnMuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gbnVsbDtcclxuICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzXHJcbiAqIGBAZXRoZXJzcHJvamVjdC93ZWIvc3JjLnRzL2luZGV4LnRzYC4gVXNlZCB0byBzdXBwb3J0XHJcbiAqIHtAbGluayBBbGNoZW15UHJvdmlkZXIuX3NlbmR9LCB3aGljaCBpcyBhbHNvIGNvcGllZCBvdmVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcclxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocGF5bG9hZC5lcnJvci5tZXNzYWdlKTtcclxuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xyXG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XHJcbiAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XHJcbn1cblxuZXhwb3J0IHsgQWxjaGVteVByb3ZpZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXByb3ZpZGVyLTkzMjk1M2U0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../ethereum/node_modules/alchemy-sdk/dist/esm/alchemy-provider-932953e4.js\n"));

/***/ })

}]);